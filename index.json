[{"content":"前言  在 Rust 的 std::maker 中有几个特殊的 trait，我们之前聊到的 Copy 就是其中一个，他们都是用来描述类型的内在属性，更多的是给编译器需要的额外信息。本篇作为初见会先从整体上概括知识点。\nSend/Sync  这两个 trait 主要针对并发编程的数据竞争的问题。在正常开发过程中我们时常会遇到一个问题就是区分哪些类型是具有并发安全的属性。例如实现了 Send trait 的类型表示它在不同线程之间进行 move 是安全的。而实现了 Sync trait 的类型表示在多个线程中使用 \u0026amp;T 是安全的。而这两个 trait 本身是由编译器自动推导的，所以我们更多看到它们是在泛型的类型约束上。真的要把一些线程不安全的类型转换成线程安全的还是得靠例如 Mutex 这些东西。\nSized  凡是能在编译阶段就能确定大小的类型都是满足 Sized 约束的。说句人话就是其实我们开发中经常遇到的大部分都满足 Sized。有一些特殊的动态大小类型不满足 Sized，例如不定长数组。因为函数的返回值必须是确定大小的类型，动态大小类型无法直接返回，必须隐藏在指针后面，所以在直觉上很少遇到这种动态类型。\nUnpin  Rust 中默认是移动语义，但是有时我们就是不希望这种移动发生。这就需要利用到 Pin 类型。而 Unpin 约束让类型不用受到这种限制。（老实说以前没做过类似的东西，所以目前还不太理解当中存在的必要性，等以后专门做一篇关于 Pin 的文章再讲）。\nauto trait  std::marker 中的 trait 都和 Rust 语言本身有着紧密关系。虽然它们任意一个概念单独拉出来都有很多其他东西，不过他们有一个共通点：那就是他们都是编译器一次帮我们在所有能够满足的类型上面实现，个人感觉有点 Golang 自动实现 interface 的那种意思。这个能力也是 Rust 提供我们的一个 feature，作为普通用户也能使用这个能力（虽然还没 stable）。这个在 Rust 中之前叫 OIBIT，现在叫 auto trait：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #![feature(negative_impls)]#![feature(auto_traits)]autotraitValid{}struct True;struct False;impl!ValidforFalse{}struct MaybeValid\u0026lt;T\u0026gt;(T);fn must_be_valid\u0026lt;T: Valid\u0026gt;(_t: T){}fn main(){// works must_be_valid(MaybeValid(True));// compiler error - trait bound not satisfied // must_be_valid( MaybeValid(False) ); }  比较有意思的是它能够通过感叹号来指定某些类型不要实现一些 trait：\n1  impl!TraitforType  ","description":"","id":0,"section":"posts","tags":null,"title":"[Rust Std Trait] std::marker 与 auto trait 初见","uri":"https://saberuster.github.io/posts/rust-trait-08/"},{"content":"前言  书接上文，这次我们来聊聊剩下的几种类型转换 trait。\nBorrow/BorrowMut  前文的 AsRef\u0026lt;T\u0026gt; 更像是简单的 T getter 逻辑。而 Borrow\u0026lt;T\u0026gt; 个人理解更多表述的是针对 T 类型的拓展，本质上是针对相同意思的不同表述。说句人话，就是类似 String 和 str 的关系，虽然类型不同功能不同，但是他们在类型含义上都是表示“字符串”的意思，所以 String 表示的 “a” 和 str 表示的 “a” 应该是相等的。所以约定对于 Eq，Ord，Hash trait 有 if x == y =\u0026gt; x.borrow() == y.borrow()。以 HashMap 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  usestd::borrow::Borrow;usestd:#️⃣:Hash;pubstruct HashMap\u0026lt;K,V\u0026gt;{// fields omitted }impl\u0026lt;K,V\u0026gt;HashMap\u0026lt;K,V\u0026gt;{pubfn insert(\u0026amp;self,key: K,value: V)-\u0026gt; Option\u0026lt;V\u0026gt;whereK: Hash+Eq{// ... }pubfn get\u0026lt;Q\u0026gt;(\u0026amp;self,k: \u0026amp;Q)-\u0026gt; Option\u0026lt;\u0026amp;V\u0026gt;whereK: Borrow\u0026lt;Q\u0026gt;,Q: Hash+Eq+?Sized{// ... }}  ToOwned  ToOwned 是 Borrow 的反向版本，功能类似 Clone， Clone 是从 \u0026amp;T 到 T，而 ToOwned 是从 \u0026amp;T 到 Borrow\u0026lt;T\u0026gt;。\n1 2 3 4 5  lets: \u0026amp;str =\u0026#34;a\u0026#34;;letss: String =s.to_owned();letv: \u0026amp;[i32]=\u0026amp;[1,2];letvv: Vec\u0026lt;i32\u0026gt;=v.to_owned();  ToString/FromStr  我们可以给类型实现 Display trait，因为 Rust 已经预定义了一个基于 Display 的实现：\n1 2 3 4 5 6 7 8 9 10  impl\u0026lt;T: fmt::Display+?Sized\u0026gt;ToStringforT{#[inline]default fnto_string(\u0026amp;self)-\u0026gt; String {usefmt::Write;letmutbuf=String::new();buf.write_fmt(format_args!(\u0026#34;{}\u0026#34;,self)).expect(\u0026#34;a Display implementation returned an error unexpectedly\u0026#34;);buf}}  我在看基于旧版本的 Rust 的书中写的 Display 是可以自动 derive 的，而我在查阅当前版本的标准库文档中已经明确说明不能 derive：\n Display is similar to Debug, but Display is for user-facing output, and so cannot be derived.\n  FromStr 提供从 \u0026amp;str 到 T 的转换：\n1 2 3 4 5  pubtraitFromStr{type Err;pubfn from_str(s: \u0026amp;str)-\u0026gt; Result\u0026lt;Self,Self::Err\u0026gt;;}  由于可能出现失败的情况所以返回的是 Result\u0026lt;Self, Self::Err\u0026gt;。\n","description":"","id":1,"section":"posts","tags":null,"title":"[Rust Std Trait] 类型转换 trait 初见（二）","uri":"https://saberuster.github.io/posts/rust-trait-07/"},{"content":"前言  虽然在 Rust 中提供了用于做基本类型转换的关键字 as，但是自定义类型也有类型转换的需求，所以 Rust 标准库为我们提供了一系列 trait 来解决这个问题。本篇文章以最短的篇幅概括 类型转换相关 trait 的主要知识点。\nAsRef/AsMut  这两个 trait 主要负责从 A 类型的 \u0026amp;self/\u0026amp;mut self 转换成 B 类型的 \u0026amp;/\u0026amp;mut：\n1 2 3 4 5 6 7 8 9 10 11 12 13  pubtraitAsRef\u0026lt;T\u0026gt;whereT: ?Sized,{pubfn as_ref(\u0026amp;self)-\u0026gt; \u0026amp;T;}pubtraitAsMut\u0026lt;T\u0026gt;whereT: ?Sized,{pubfn as_mut(\u0026amp;mutself)-\u0026gt; \u0026amp;mutT;}  需要注意的点：\n 这两个都是用来做那种比较简单的转换，类似直接返回的那种。如果在类型转换消耗很大应该考虑使用 From 或者自定义函数 这两个 trait 做的类型转换都不能失败。如果类型转换存在失败的可能需要自己写自定义函数 AsRef 和 Borrow 的区别还没真正理解，先挖个坑，等研究 HashMap 的时候再填  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  externcratehello_rust;struct Name(\u0026amp;\u0026#39;staticstr);fn show_name\u0026lt;T: AsRef\u0026lt;Name\u0026gt;\u0026gt;(item: T){println!(\u0026#34;name is :{}\u0026#34;,item.as_ref().0);}struct Bus{vehicle_name: Name,}implAsRef\u0026lt;Name\u0026gt;forBus{fn as_ref(\u0026amp;self)-\u0026gt; \u0026amp;Name{\u0026amp;self.vehicle_name}}struct Apple{fruit_name: Name,}implAsRef\u0026lt;Name\u0026gt;forApple{fn as_ref(\u0026amp;self)-\u0026gt; \u0026amp;Name{\u0026amp;self.fruit_name}}fn main(){letbus=Bus{vehicle_name: Name(\u0026#34;bus\u0026#34;),};letapple=Apple{fruit_name: Name(\u0026#34;apple\u0026#34;),};show_name(bus);show_name(apple);}  From/Into  这两个 trait 主要处理 A 和 B 值类型之间的相互转换。标准库中还存在他俩的可失败版本 TryFrom/TryInto。\n1 2 3 4 5 6 7 8  pubtraitFrom\u0026lt;T\u0026gt;{#[lang = \u0026#34;from\u0026#34;]pubfn from(T)-\u0026gt; Self;}pubtraitInto\u0026lt;T\u0026gt;{pubfn into(self)-\u0026gt; T;}  需要注意的点：\n 因为实现 From 时标准库会有一个 Into 的预制实现。然而反过来并不是，所以我们应该优先选择实现 From trait 声明时优先使用 Into，因为 From 会自动实现 Into 而 Into 并不会自动实现 From From/Into 都不允许失败，如果有可能失败可以选择 TryFrom/TryInto From 在 Rust 的错误处理中应用广泛  ","description":"","id":2,"section":"posts","tags":null,"title":"[Rust Std Trait] 类型转换 trait 初见（一）","uri":"https://saberuster.github.io/posts/rust-trait-06/"},{"content":"前言  由于 ops 中的很多 trait 功能类似，所以就不一个一个来了。本篇文章以最短的篇幅概括 std::ops 中还未提及的主要知识点。\n运算符重载  最基础的就是对四则运算之类的操作符进行重载了。这里借用计算点坐标的例子来演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  externcratehello_rust;usestd::ops::Add;#[derive(Debug, Clone, Copy)]struct Point{x: i32,y: i32,}implAddforPoint{type Output=Self;fn add(self,rhs: Point)-\u0026gt; Self{Self{x: self.x+rhs.x,y: self.y+rhs.y,}}}fn main(){println!(\u0026#34;{:?}\u0026#34;,Point{x: 1,y: 2}+Point{x: 2,y: 1});}  FnOnce/FnMut/Fn  Rust 中用 fn 可以定义函数，而 Fn 可以对函数做抽象。三种不同形态对应 self 参数的传递类型。FnOnce 对应 move 传递，这样的函数不能执行多次，所以签名带了个 Once。FnMut/Fn 分别对应 \u0026amp;mut Self 和 \u0026amp;Self 类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  pubtraitFnOnce\u0026lt;Args\u0026gt;{type Output;pubextern\u0026#34;rust-call\u0026#34;fn call_once(self,args: Args)-\u0026gt; Self::Output;}pubtraitFnMut\u0026lt;Args\u0026gt;: FnOnce\u0026lt;Args\u0026gt;{pubextern\u0026#34;rust-call\u0026#34;fn call_mut(\u0026amp;mutself,args: Args)-\u0026gt; Self::Output;}pubtraitFn\u0026lt;Args\u0026gt;: FnMut\u0026lt;Args\u0026gt;{pubextern\u0026#34;rust-call\u0026#34;fn call(\u0026amp;self,args: Args)-\u0026gt; Self::Output;}letx=String::from(\u0026#34;x\u0026#34;);letconsume_and_return_x=move||x;// FnOnce() -\u0026gt; String letmutsquare_x=||x*=x;// FnMut() letdouble=|x|x*2;// Fn()   编译器在自动为闭包实现 trait 的时候会先试 Fn 不行再 FnMut 最后 FnOnce。\n文档中特别提到如果 F 实现了 Fn 那么自动 \u0026amp;F 也实现了 Fn。这句话我们可以利用下面的例子来感受一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  externcratehello_rust;fn test_fn\u0026lt;T\u0026gt;(f: \u0026amp;T)whereT: Fn(),{f();}fn main(){leta=||println!(\u0026#34;hello world\u0026#34;);test_fn(\u0026amp;a);}  Range 语法  Range 语法总共六种形态：\n1 2 3 4 5 6 7 8 9 10 11 12  externcratehello_rust;fn main(){letarr=[0,1,2,3];assert_eq!([0,1,2,3],arr[..]);assert_eq!([1,2,3],arr[1..]);assert_eq!([0,1],arr[..2]);assert_eq!([0,1,2],arr[..=2]);assert_eq!([1],arr[1..2]);assert_eq!([1,2],arr[1..=2]);}  ","description":"","id":3,"section":"posts","tags":null,"title":"[Rust Std Trait] std::ops 初见","uri":"https://saberuster.github.io/posts/rust-trait-05/"},{"content":"前言  在平时的开发中，我们可能需要利用析构函数来做一些收尾工作。在 Rust 中我们可以利用 Drop trait 来实现。本篇文章将会用最短的篇幅覆盖 Drop 的主要知识点。\nimpl Drop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  externcratehello_rust;struct DT{id: i32,}implDropforDT{fn drop(\u0026amp;mutself){println!(\u0026#34;drop call!\u0026#34;);}}fn main(){letdt=DT{id: 1};println!(\u0026#34;{:?}\u0026#34;,dt.id);}  主动析构  一般我们定义的局部变量生命周期都是当前语句块， 析构顺序“先进后出”。不过 Rust 中我们也可以手动使用 drop 函数提前结束它的生命周期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  externcratehello_rust;struct DT{id: i32,}implDropforDT{fn drop(\u0026amp;mutself){println!(\u0026#34;drop call!\u0026#34;);}}fn main(){letdt=DT{id: 1};drop(dt);// 这里不能直接调用 dt.drop() println!(\u0026#34;end!\u0026#34;);}  drop 函数体内啥也没有，单纯就是把所有权拿到然后函数结束才好让析构函数执行。也因为它利用了 Rust 默认的移动语义，它和 Copy trait 是有冲突的。所以在 Rust 中同一个类型是不允许同时实现 Copy 和 Drop 的。\n析构函数的调用是在编译阶段就确定好的，而我们可以在代码的不同执行路径中主动析构从而影响析构函数的调用顺序，那这不是矛盾吗？\n1 2 3 4 5  matchcondition{Some(1)=\u0026gt;drop(var1)Some(2)=\u0026gt;drop(var2)_=\u0026gt;{}}  其实这里我们可以理解为 Rust 会用一个布尔值来判断，如果执行到最后还没有析构过才会调用析构函数。如果在执行期间已经析构了，是不会重复调用的。\n","description":"","id":4,"section":"posts","tags":null,"title":"[Rust Std Trait] Drop 初见","uri":"https://saberuster.github.io/posts/rust-trait-04/"},{"content":"前言  Copy 作为能够影响编译器行为的 trait 对我们理解 Rust 基础有着重要作用，而 Clone 是我们作为搬砖工人能够自定义复制行为的 trait。本篇文章将会用最短的篇幅覆盖 Copy 和 Clone 的主要知识点。\n至关重要的 Copy trait  提问，以下代码为何 print1 行不报错：\n1 2 3 4 5 6 7 8  externcratehello_rust;fn main(){letnum1=1i32;letnum2=num1;println!(\u0026#34;{}\u0026#34;,num1);// print 1 println!(\u0026#34;{}\u0026#34;,num2);// print 2 }  其实这里就需要理解 Copy trait 在当中起的作用。如果一个类型实现了 Copy trait，那么它在变量绑定，函数参数传递，函数返回值的场景等场景下都是 copy 语义，而不是默认的 move 语义。上面的例子因为 Rust 已经帮你把 i32 的 Copy trait 实现好了，所以才以 Copy 语义使用。所以，即使是我们自己定义的类型，只要实现了 Copy trait 也会变成 Copy 语义：\n1 2 3 4 5 6 7 8 9 10 11  externcratehello_rust;#[derive(Debug, Copy, Clone)]struct TA(i32);fn main(){lett1=TA(1);lett2=t1;println!(\u0026#34;{:?}\u0026#34;,t1);// print 3 println!(\u0026#34;{:?}\u0026#34;,t2);// print 4 }   Copy trait 对类型有一定要求，如果想让我们的自定义类型实现 Copy trait，那么它的所有成员都必须是实现了 Copy trait 的。标准库除常规 impl 的类型外还特别提及以下类型也是 Copy 的：\n 函数/函数指针 元素为 Copy 的数组和元组 闭包（不捕获或者捕获 Copy）  能够自定义的 Clone trait  Copy 的行为我们是无法控制的。如果我们想自定义例如“类型深复制”的行为，可以实现 Clone trait。Copy 是隐式改变编译器的行为，而 Clone 需要我们显式调用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  externcratehello_rust;#[derive(Debug, Clone)]struct CT{field1: i32,field2: bool,}fn main(){letct=CT{field1: 1,field2: false,};println!(\u0026#34;{:?}\u0026#34;,ct.clone());}  如果我们想自定义 Clone trait 的行为可以手动实现 trait，Rust 不会限制你的具体自定义实现，不过对于同时还要实现 Copy trait 的类型都确保 Clone 和 Copy 代表的语义相同。可以直接在 derive 中二连使用。\n1 2 3 4 5 6 7 8 9 10 11  implCloneforCT{fn clone(\u0026amp;self)-\u0026gt; Self{*self}}// or #[derive(Debug, Copy, Clone)]struct CT{field1: i32,field2: bool,}  ","description":"","id":5,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] Copy/Clone 初见","uri":"https://saberuster.github.io/posts/rust-trait-03/"},{"content":"前言  由于需要考虑全序关系（例如 Rust 浮点数中的 NaN），Rust 中有两套 trait 分别定义满足“全序”关系的 Ord/Eq 只能构成“偏序”关系的 PartialOrd/PartialEq。本文致力于用最短的篇幅覆盖标准库中Ord,Eq,PartialOrd,PartialEq的主要知识点。\nEq/PartialEq  Eq 和 PartialEq 在概念上的区别主要是否满足 a == a，乍看之下是句废话。实则不然，例如 a = NaN 就是特例。而在 trait 的定义上 Eq 是基于 PartialEq 的，Eq 自己更多是起修饰作用，在#[derive]中，PartialEq 在类型字段全部相等时为 true反之false，而 Eq 只是约束类型全字段也满足 Eq。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  externcratehello_rust;#[derive(Debug, Eq)]struct MyItem{id: i32,//... other Eq fields }implPartialEqforMyItem{fn eq(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; bool {self.id==other.id}}fn main(){letitem1=MyItem{id: 1};letitem2=MyItem{id: 1};assert_eq!(item1,item2);}   不难看出如果我们想用这套 trait，PartialEq 需要无脑怼上。需不需要 Eq 可以再考虑。\nOrd/PartialOrd  和前文一样，做这种区分就是因为一些特殊值例如 NaN \u0026lt; 0 == false 并且 NaN \u0026gt;= 0 == false。而在 trait 定义上 PartialOrd 基于 PartialEq 而 Ord 是 Eq + PartialOrd。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  usestd::cmp::Ordering;#[derive(Eq)]struct Person{id: u32,name: String,height: u32,}implPartialOrdforPerson{fn partial_cmp(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; Option\u0026lt;Ordering\u0026gt;{Some(self.cmp(other))}}implOrdforPerson{fn cmp(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; Ordering{self.height.cmp(\u0026amp;other.height)}}implPartialEqforPerson{fn eq(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; bool {self.height==other.height}}  总结  虽然上例演示使用了这套 trait，不过还是要说除 == 和 != 以外的其他运算符的语义都比较固定，适用范围有限，避免滥用。\n","description":"","id":6,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] (Partial)Ord/Eq 初见","uri":"https://saberuster.github.io/posts/rust-trait-02/"},{"content":"前言  本文致力于用最短的篇幅覆盖标准库中Default trait的主要知识点。\n功能介绍  Default trait 可以用于定义类型的默认值。基础用法举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #[derive(Debug)]struct TraitTest{enable: bool,type_id: i32,}implDefaultforTraitTest{fn default()-\u0026gt; Self{TraitTest{enable: true,type_id: 1,}}}fn main(){lettd=TraitTest::default();println!(\u0026#34;{:?}\u0026#34;,td);}  如果我们就是想用字段类型本身的默认值，不想像上面的例子一样指定特定值的话，用上面的写法明显会有大段的冗余代码。\n标准库已经为我们想到了：\n1 2 3 4 5 6 7 8 9 10  #[derive(Default, Debug)]struct TraitTest2{a: i32,b: bool,}fn main(){lettd2=TraitTest2::default();println!(\u0026#34;{:?}\u0026#34;,td2);}  这里需要注意的是在使用 #[derive] 的时候要确保类型的所有字段也都实现了 Default trait。\n一些基础类型在定义 Default trait 源码已经给他做实现了，所以我们可以直接用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /// default.rs 源码 macro_rules!default_impl{($t:ty,$v:expr,$doc:tt)=\u0026gt;{#[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]implDefaultfor$t{#[inline]#[doc = $doc]fn default()-\u0026gt; $t{$v}}}}default_impl!{(),(),\u0026#34;Returns the default value of `()`\u0026#34;}default_impl!{bool,false,\u0026#34;Returns the default value of `false`\u0026#34;}default_impl!{char,\u0026#39;\\x00\u0026#39;,\u0026#34;Returns the default value of `\\\\x00`\u0026#34;}default_impl!{usize,0,\u0026#34;Returns the default value of `0`\u0026#34;}/// ... 其他定义就省略了   在实践中我们经常会遇到一种情况：只想指定类型其中一个或几个字段的值。这种需求也有比较完美的解决方案：\n1 2 3 4 5 6 7 8  fn main(){lettd3=TraitTest{enable: false,..TraitTest::default()};println!(\u0026#34;{:?}\u0026#34;,td3);}  你可能觉得像上面一样在 TraitTest 里面用 TraitTest::default() 有点冗余。这个标准库也已经想到了(虽然目前还没stable)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #![feature(default_free_fn)]usestd::default::default;/// ... def code fn main(){lettd3=TraitTest{enable: false,..default()};println!(\u0026#34;{:?}\u0026#34;,td3);}  总结  虽然Rust比较复杂，但是真的用起来会发现不管是工具链还是代码书写总体来说是舒服的。尤其2019和2020年都已肉眼可见的速度变好。接下来我也会定期更一些Rust相关的基础文章为将来撸代码做准备。\n","description":"","id":7,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] Default 初见","uri":"https://saberuster.github.io/posts/rust-trait-01/"},{"content":"问题描述  在ue4开发中本人之前一直有一种接口定义的困境，定义支持蓝图的接口吧在代码里用着不舒服，有点影响开发效率。定义只支持C++的接口吧蓝图还要用。\n后来翻 GameplayAbility 插件的源码的时候发现人家的解决方案挺简单有效的，特此拿来借鉴一下。\n问题的解决方式 在 GameplayAbility 插件中定义了一个 IAbilitySystemInterface 接口，该接口只有一个普通的 C++ 纯虚函数。这种定义也是我们在代码里用着比较舒服的。缺点就是本身在蓝图中用不了。\n1 2 3 4 5 6 7  class GAMEPLAYABILITIES_API IAbilitySystemInterface { GENERATED_IINTERFACE_BODY() /** Returns the ability system component to use for this actor. It may live on another actor, such as a Pawn using the PlayerState\u0026#39;s component */ virtual UAbilitySystemComponent* GetAbilitySystemComponent() const = 0; };   为了支持蓝图，它的做法是在蓝图函数库中定义一个相同功能的静态函数：\n1 2  UFUNCTION(BlueprintPure, Category = Ability) static UAbilitySystemComponent* GetAbilitySystemComponent(AActor *Actor);   从蓝图侧传入Actor然后在代码里面判断Actor是否实现了接口，如果实现了直接调用接口，没有的话还可以通过遍历组件找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  if (Actor == nullptr) { return nullptr; } const IAbilitySystemInterface* ASI = Cast\u0026lt;IAbilitySystemInterface\u0026gt;(Actor); if (ASI) { return ASI-\u0026gt;GetAbilitySystemComponent(); } if (LookForComponent) { /** This is slow and not desirable */ ABILITY_LOG(Warning, TEXT(\u0026#34;GetAbilitySystemComponentFromActor called on %s that is not IAbilitySystemInterface. This slow!\u0026#34;), *Actor-\u0026gt;GetName()); return Actor-\u0026gt;FindComponentByClass\u0026lt;UAbilitySystemComponent\u0026gt;(); } return nullptr;   个人感觉这种方式比直接在接口文件中直接定义蓝图可用的接口灵活很多。\n","description":"","id":8,"section":"posts","tags":["折腾日记","UE4","动画","C++"],"title":"UE4 中一种 Blueprint\u0026C++ 统一化接口的小技巧","uri":"https://saberuster.github.io/posts/ue4-02/"},{"content":"前言  作为虚幻4的白嫖党，Mixamo 一定是不能错过的。本篇文章总结了 Mixamo 中动画迁移到虚幻4项目中的知识点。\n导入基础骨架  Mixamo 中动画的骨架和虚幻4小白人是不一样的，如果我们直接把动画导入进引擎我们小白人也用不了。解决方案就是把 Mixamo 中那套通用的骨架先导入进引擎，然后再在引擎中把动画 retarget 到小白人的骨架上。\n 因为我们要导入的骨架其实就是做个中间层，不需要乱七八糟的贴图材质啥的，所以我就选择了 Mixamo 中的 YBot 角色，因为它比较干净。这里要注意导出的时候要选 T Pose。\n然后将其导入引擎。之后我们从 Mixamo 中导出的所有动画在导入引擎的时候都选择这个骨架就可以了。\n类人绑定  为了能够把动画转到小白人上我们需要将骨架进行类人绑定。这是虚幻4中的一个现成的功能，只需要自己配置一下。\n小白人自己的骨架知道让系统自动绑定就行了。主要就是上面提到的 Mixamo 的基础骨架。因为它和小白人骨架的差别较大需要自己耐心一个一个调一调。\n 完成之后需要在骨骼的那个树状图的 Option 中开启 retarget options 显示。然后把除了 Hips 以外的所有骨骼设置成skeleton（默认是 Animation）。\n把小白人设置成 T Pose  小白人默认是 A Pose。为了能够迁移我们需要手动把他调成 T Pose 的。直接再骨骼界面旋转调整，满意后点击 retarget manager 页面的 ModifyPose，选择 Current Pose 即可。\n开始迁移动画  完成上面的操作我们就可以快乐的把 Mixamo 中的动画给小白人用啦！想迁移单个动画就在动画序列上右键然后 retarget。要是想一次迁移全部就直接在骨骼上右键retarget就可以了。\n参考索引(需要翻墙) ","description":"","id":9,"section":"posts","tags":["折腾日记","UE4","动画"],"title":"在虚幻4中使用 Mixamo 的动画","uri":"https://saberuster.github.io/posts/ue4-01/"},{"content":" 在使用 Houdini 构建自己的 HDA 工具的时候经常会需要通过 Input 传入基础几何体信息。而我们又希望在无输入的情况下能有个默认值效果。经过几个 HDA 工具的开发，自己简单总结成了以下两步：\n利用 switchif 做默认值切换  这里选择 switchif 而不是 switch 是因为 switchif 是在 0 和 1 之间切换，而 switch 可以不止两个输入。在节点的表述性上更加直观。其次 switchif 内置选项中集成了 npoints 功能（虽然手写个表达式就多敲7个字母的问题而已，不过等节点多起来脑子要判断这个框里写的啥还是要想一下）。\n switchif 需要注意两点：节点选择 0 还是 1 分别对应断言的 false 和 true，与断言语义无关。还可以利用 spare input 将非输入节点引入断言。\n利用 disable when 禁用默认配置  在连接了 Input 以后我们希望能够把默认配置的选项都禁用掉，这时就需要用到 disable when 的语法:\n这里的语法在官方文档有比较全面的参考\n示例 HDA 下载地址\n ","description":"","id":10,"section":"posts","tags":["折腾日记","Houdini","3D美术","Houdini Tips"],"title":"【Houdini Tips】给输入设置默认几何体","uri":"https://saberuster.github.io/posts/houdini-tips-01/"},{"content":"前言  本来近期想在blender里面做一小套场景拿到UE4里面测试一下光照和后期的。陆陆续续做了些场景内容后发现一个很让我头疼的问题：每次我想在Mesh上改点什么都需要把之后展UV，LowPoly，HighPoly，各种贴图烘焙等整个流程全部都走一遍。作为一名非专业3D美术技术人员，我并没有找到什么好的办法来解决这个问题。然而对于我来讲每天的工作内容很多，不可能在这上面浪费太多时间，所以我重拾起了电脑里面快半年没打开的houdini打算利用它来搞定这个需求。经过两天的研究初步总结出了一套适用于我个人的3D美术资产的pipline:\nblender打Mesh草稿-\u0026gt;去houdini里面创建HDA进行程序生成和参数化-\u0026gt;利用Gamedev插件做贴图烘焙和fbx导出或者直接利用houdini engine直接把HDA怼到引擎里面\n PS:其实Blender利用UE4官方的SendToUnreal插件也能直接把Mesh怼到引擎里面预览，减轻了Mesh导入导出的成本，不过在blender端修改Mesh的工作量还是没有减少。所以我目前觉得SendToUnreal更多的是作为引擎多边形编辑工具的拓展，重点在我上面的打Mesh草稿阶段，对整个美术资产制作流程的优化作用有限。\n关于 procedural modeling 的思考  不断完善自己工具链的过程也是明确自身需求的过程。就我个人而言因为美术功底和艺术上的创造力近乎于无，最多就是去artstation上找找灵感，然后到处翻教程。所以本身无法在这个方向获得足够的竞争力。而相比之下鄙人在编程上面相对擅长一些，所以我是更能够接受把程序化建模引入工作流并不断优化，同时放弃一些美术上自由度的方案。\nDemo示例 下面通过一个蒸笼的模型来演示一下整个流程：\n 首先创建一个叫“steamer”的HDA。然后将其划分为4部分：\n body 是蒸笼的主体，主要就是一个Tube在两边挤出然后利用polybridge掏空中间。    grid 是蒸笼每一层的网格底。\n就是简单的矩形变换然后和上面body的BaseTube做布尔运算切出需要的部分，就不上图了。\n  cap 是蒸笼的顶部原型盖子。\n  盖子部分我的做法是把一个平面投射到球体上，然后通过调整球体Y轴的半径来控制盖子的弧形感觉。\n关于UV的小技巧  虽然我们的模型面数很少，不过如果我们频繁HDA参数调整模型的拓扑结构，autouv所消耗的时间还是很多的，直观的感受就是电脑会卡一下。所以一般会在HDA的参数中添加一个启用UV的参数然后在switch节点中通过取值0或1来开关UV的自动展开。这样我们在频繁调整的时候就不会卡了。\n 程序化建模对于新手来说最需要注意的一点就是对于UV空间的重复利用。例如像我们的蒸笼模型中，我们的蒸笼主体其实就是一个蒸笼格子一个个往上摞。所以他们完全可以公用同一块UV空间。当然这并不是完全没有问题的，如果你需要在某个格子上添加特殊的细节的话这种公用方案就无法满足。还有一点就是在UE4里面光照贴图要求UV之间是不能重叠的。不过这个其实引擎已经帮我们想到了，在我们把模型导入引擎的时候，引擎默认会帮我们生成一套专门的用作光照相关的UV(当然我们自己生成也可以)。就像我之前所说的，目前来讲“在某个格子上添加特殊的细节”这种操作并不能在美术上让我更有竞争力，所以我选择放弃这一点自由度换取数字资产在管线和效率上的优势。\n导出fbx以及烘焙各种贴图  houdini对我们常用的fbx和各种贴图的支持也是很好的。其中fbx导出没什么可说的，大家都一样。关于贴图的烘焙我们可以通过Gamedev（SideFxLabs）的插件里的maps backer来完成。\n我们可以看到在maps backer中我们常用的几种例如法线贴图，Curature贴图，AO贴图等等都支持。\n我们在用SP的烘焙的时候有一个选项就是OnlyByMeshName的选项。而在houdini中我们可以通过在烘焙前利用align and distribute节点让不同名称的Mesh分开依次间隔排列，这样就达到了和OnlyByMeshName相同的效果。\n展望  之前还接触过PDG相关的东西，不过目前来讲自己还没有这种需求，如果以后有机会我还是愿意试试的。随着技术的发展各个细分领域都可能会出现或者已经存在更加专业的解决方案，很难再出现一个工具cover所有需求的情况。那么多关注自身工具链的构建将各种解决方案有机的结合起来在当下就成了一件很重要的事情。\n","description":"","id":11,"section":"posts","tags":["折腾日记","Houdini","3D美术","工具链"],"title":"将houdini procedural modeling加入自己的工作流","uri":"https://saberuster.github.io/posts/houdini-01/"},{"content":"前言  依稀记得上次折腾自己的博客还是2018年。后来感觉无非就是写博客展示出来，啥平台都可以啊。所以之后又在零零散散几个能写文章的平台（例如知乎）更新过一些文章。直到有一天我遇见了redblobgames，里面的文章有很多能交互的东西让人对文章的内容有更深的理解。本着“我也想这样”的本能开启了这次的折腾的不归路。\n关于为什么选择Hugo  主要因为自己本身对Golang比较熟悉所以选择了Hugo。万一拓展点什么功能说不定还能贡献点代码参与参与开源社区。\n博客的主要内容  2018年的时候其实对自己的认知还是一个纯码农。所以更多的关注的是自己感兴趣的一些技术趋势。后来发现能安心做个我心目中的超级码农和当科学家一样是一个门槛奇高无比的事情。因为我觉得当今的软件开发的技术迭代我觉得已经超越了个人能承受的极限，所以想在保证本职专业度的前提下再拓展自己新的认知领域是一件很难的事情，除非能做到站在更高的认知上俯瞰技术的发展。2年过去了，我选择对自己的定位做出一定调整哈哈，超级码农对我来说还是有点不太现实。\n扯了点别的，回到主题博客内容按我目前的构想主要还是先以编程技术为主，之后再包含一些自己折腾各种游戏设计，3D美术相关东西的心得吧，也借此让自己更加多元化一点。\n说好的交互内容呢  博客先支个摊出来熟悉熟悉代码，目前计划先拿个主题先顶着，以后先换个自己的主题然后开始折腾交互内容。\n最后 希望这次能够坚持下来吧!!! ","description":"","id":12,"section":"posts","tags":["折腾日记"],"title":"使用hugo重建我的博客","uri":"https://saberuster.github.io/posts/my-first-post/"},{"content":"这个人很内向，还没想好如何介绍自己。\n","description":"一个喜欢编程和折腾的追风少年","id":13,"section":"","tags":null,"title":"关于我","uri":"https://saberuster.github.io/about/"}]