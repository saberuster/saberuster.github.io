<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>saberuster 的博客</title>
    <link>https://saberuster.github.io/</link>
    <description>Recent content on saberuster 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>saberuster@gmail.com (saberuster)</managingEditor>
    <webMaster>saberuster@gmail.com (saberuster)</webMaster>
    <copyright>&amp;copy;{year} saberuster, All Rights Reserved</copyright>
    <lastBuildDate>Wed, 10 Mar 2021 18:53:33 +0000</lastBuildDate>
    
        <atom:link href="https://saberuster.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      

      
      <item>
        <title>[Bevy 源码解析] ECS 基础</title>
        <link>https://saberuster.github.io/notes/bevy-01/</link>
        <pubDate>Wed, 10 Mar 2021 18:53:33 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Wed, 10 Mar 2021 18:53:33 +0000</atom:modified>
        <guid>https://saberuster.github.io/notes/bevy-01/</guid>
        <description>前言 ECS 系统数据的保存方式分为两种： 一种是像数据库一样，数据表结构作为 Entity 每个字段作为 Component，这种结构迭代数据比较快（要不人家数据库</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>【随笔】地球编年史(一)无尽的起源</title>
        <link>https://saberuster.github.io/notes/book01-01/</link>
        <pubDate>Wed, 10 Mar 2021 12:38:16 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Wed, 10 Mar 2021 12:38:16 +0000</atom:modified>
        <guid>https://saberuster.github.io/notes/book01-01/</guid>
        <description>前言 很早之前就听说过 &amp;laquo;地球编年史&amp;raquo; 的大名，不过一直没有机会沉下心来研读此书。因为个人的工作转变，需要吸取养分进行内容</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>未来一段时间博客内容的一些思考</title>
        <link>https://saberuster.github.io/posts/dairy-01/</link>
        <pubDate>Mon, 08 Mar 2021 23:40:01 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Mon, 08 Mar 2021 23:40:01 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/dairy-01/</guid>
        <description>在我个人的技术栈中 Rust 在适用广度上比其他语言更像 C++。所以前段时间坚持更新一段时间的 Rust 基础，把一些基本的知识点全都过了一遍(还有一些比较复杂</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Unreal源码系列]</title>
        <link>https://saberuster.github.io/posts/unreal-src-02/</link>
        <pubDate>Fri, 05 Mar 2021 07:39:24 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Fri, 05 Mar 2021 07:39:24 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/unreal-src-02/</guid>
        <description></description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Unreal源码系列]前言</title>
        <link>https://saberuster.github.io/posts/unreal-src-01/</link>
        <pubDate>Fri, 05 Mar 2021 07:14:18 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Fri, 05 Mar 2021 07:14:18 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/unreal-src-01/</guid>
        <description>前言 前段时间摸鱼更了点 Rust 的基础，今天开始回归正途。其实 Unreal 相关的源码解析文章大佬们已经写过很多了，而且都很深入。这也导致像我这样的萌新看了心里</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[随笔]OpenRA 图形模块</title>
        <link>https://saberuster.github.io/notes/openra-03/</link>
        <pubDate>Fri, 05 Mar 2021 06:37:48 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Fri, 05 Mar 2021 06:37:48 +0000</atom:modified>
        <guid>https://saberuster.github.io/notes/openra-03/</guid>
        <description>图形渲染模块都在 Graphics 文件夹中 模型相关 Model.cs ModelAnimation.cs ModelRenderer.cs 演示相关 Pallete.cs PaletteReference.cs 地图渲染 WorldRenderer Sprite 渲染</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[随笔]OpenRA 文件模块</title>
        <link>https://saberuster.github.io/notes/openra-02/</link>
        <pubDate>Thu, 04 Mar 2021 18:08:08 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Thu, 04 Mar 2021 18:08:08 +0000</atom:modified>
        <guid>https://saberuster.github.io/notes/openra-02/</guid>
        <description>FileSystem 做上层调用的管理类， FileSystem 管理底层的 package 一个package 可以拥有多个文件。 Package 当前有两个实现，Zip 和 文件夹。 缓存是用文件名做key返回所有包含</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[随笔]OpenRA 源码（一）Server 启动与主循环Tick</title>
        <link>https://saberuster.github.io/notes/openra-01/</link>
        <pubDate>Wed, 03 Mar 2021 13:45:46 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Wed, 03 Mar 2021 13:45:46 +0000</atom:modified>
        <guid>https://saberuster.github.io/notes/openra-01/</guid>
        <description>前言 最近听闻 Rust 社区要做 OpenRA 的 rust 版本，我也想借此机会提升一下自己在 Rust 和引擎架构上的知识。计划每天花一点点时间看一点源码，写写笔记。如果有机会混混</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>OpenRA</category>
            
          
            
              <category>随笔</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>Blender Basic 01</title>
        <link>https://saberuster.github.io/posts/blender-basic-01/</link>
        <pubDate>Wed, 03 Mar 2021 07:25:39 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Wed, 03 Mar 2021 07:25:39 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/blender-basic-01/</guid>
        <description>前言 经过两天的折腾利用 blender 完成了一个小的45度场景练习。主要目的是为了踩坑和增加场景的制作效率。 最终结果图： 经验 利用 blender 自带的布尔工具插件进行造</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]闭包</title>
        <link>https://saberuster.github.io/posts/rust-basic-08/</link>
        <pubDate>Mon, 01 Mar 2021 11:36:26 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Mon, 01 Mar 2021 11:36:26 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-08/</guid>
        <description>前言 本文主要覆盖闭包的基础知识点。 基本语法 1 letadd=|a:i32,b:i32|-&amp;gt;i32 {returna+b;}; 闭包的返回值和参数类型是可以省略的： 1 letadd=|a,b|{returna+b;}; 和普通函数一样，最后的 return 也可以省略： 1 letadd=|a,b|{a+b}; 如果只有一条</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]动态分派和静态分派</title>
        <link>https://saberuster.github.io/posts/rust-basic-07/</link>
        <pubDate>Mon, 01 Mar 2021 11:34:37 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Mon, 01 Mar 2021 11:34:37 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-07/</guid>
        <description>前言 本文主要包含动态分派和静态分派的主要知识点。 静态分派 静态分派就是指程序具体调用哪个函数在编译阶段就能确定下来。Rust 中可以通过泛型和 impl</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Edition Guide</category>
            
          
            
              <category>Programing</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]模式解构</title>
        <link>https://saberuster.github.io/posts/rust-basic-06/</link>
        <pubDate>Sun, 28 Feb 2021 07:39:50 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Sun, 28 Feb 2021 07:39:50 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-06/</guid>
        <description>前言 模式结构是写 Rust 代码中最常用到的设计。本文主要关注模式解构的相关知识点。 一般形式 模式解构可以用在： let 声明 函数和闭包的参数列表 match 表达式 if let 表</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Edition Guide</category>
            
          
            
              <category>Programing</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]初探泛型</title>
        <link>https://saberuster.github.io/posts/rust-basic-05/</link>
        <pubDate>Sun, 28 Feb 2021 02:53:16 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Sun, 28 Feb 2021 02:53:16 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-05/</guid>
        <description>前言 本文囊括 Rust 中泛型的主要知识点。 泛型的一般形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 enum MyOption&amp;lt;T&amp;gt;{Some(T),None,}struct Num&amp;lt;T=i32&amp;gt;{data: Option&amp;lt;T&amp;gt;}fn test_fn&amp;lt;T&amp;gt;(param: T)-&amp;gt; bool fntest_fn&amp;lt;T,U&amp;gt;(param: T,param2: U)-&amp;gt; bool impl&amp;lt;T,U&amp;gt;Into&amp;lt;U&amp;gt;forTwhereU: From&amp;lt;T&amp;gt;{fn into(self)-&amp;gt; U{U::from(self)}} 泛型参数约束 Rust 中有两种</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Edition Guide</category>
            
          
            
              <category>Programing</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]初探生命周期标记</title>
        <link>https://saberuster.github.io/posts/rust-basic-04/</link>
        <pubDate>Sat, 27 Feb 2021 03:23:02 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Sat, 27 Feb 2021 03:23:02 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-04/</guid>
        <description>前言 生命周期标记主要用来处理生命周期跨函数时的情况。 标记形式 生命周期标记的一般形式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &amp;amp;i32// a reference &amp;amp;&amp;#39;ai32// a reference with an explicit lifetime</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Edition Guide</category>
            
          
            
              <category>Programing</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]借用与借用规则</title>
        <link>https://saberuster.github.io/posts/rust-basic-03/</link>
        <pubDate>Wed, 24 Feb 2021 20:02:06 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Wed, 24 Feb 2021 20:02:06 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-03/</guid>
        <description>前言 本文以最短篇幅概括借用和借用规则的相关知识点。 借用 在 Rust 中，变量除了可以直接进行所有权转移，还可以借用。借用分为两种：只读借用（&amp;amp;</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Edition Guide</category>
            
          
            
              <category>Programing</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] Iterator 初见</title>
        <link>https://saberuster.github.io/posts/rust-trait-09/</link>
        <pubDate>Tue, 23 Feb 2021 20:30:25 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Tue, 23 Feb 2021 20:30:25 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-09/</guid>
        <description>前言 迭代器是 Rust 中的重要功能之一，在 Rust 中迭代器指的是实现了 Iterator trait 的类型。本文以最短篇幅囊括迭代器的相关知识点。 实现 Interator 1 2 3 4 5 6 7 8 9 10 11 12 13 14</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Std</category>
            
          
            
              <category>Programing</category>
            
          
            
              <category>Rust trait</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]所有权与移动语义</title>
        <link>https://saberuster.github.io/posts/rust-basic-02/</link>
        <pubDate>Tue, 23 Feb 2021 16:00:30 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Tue, 23 Feb 2021 16:00:30 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-02/</guid>
        <description>前言 本文以最短篇幅概述 Rust 所有权和移动语义的基础知识点。之后几篇都会是所有权和生命周期的文章，这里先把基础的点整理一下。 想解决的问题 思考以下场</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Edition Guide</category>
            
          
            
              <category>Programing</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust 基础知识]mut 与可变性</title>
        <link>https://saberuster.github.io/posts/rust-basic-01/</link>
        <pubDate>Tue, 23 Feb 2021 15:56:10 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Tue, 23 Feb 2021 15:56:10 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-basic-01/</guid>
        <description>前言 本篇文章以最短的文字囊括 Rust 可变性的主要知识点。 声明可变变量 1 letmutx=5; 我们在理解它的时候需要把 mut x 理解为一个整体，所以我们在模式解构元组的时候会</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Std</category>
            
          
            
              <category>Programing</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] std::marker 与 auto trait 初见</title>
        <link>https://saberuster.github.io/posts/rust-trait-08/</link>
        <pubDate>Sun, 21 Feb 2021 20:19:17 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Sun, 21 Feb 2021 20:19:17 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-08/</guid>
        <description>前言 在 Rust 的 std::maker 中有几个特殊的 trait，我们之前聊到的 Copy 就是其中一个，他们都是用来描述类型的内在属性，更多的是给编译器需要的额外信息。本篇作为</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] 类型转换 trait 初见（二）</title>
        <link>https://saberuster.github.io/posts/rust-trait-07/</link>
        <pubDate>Sun, 21 Feb 2021 03:12:47 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Sun, 21 Feb 2021 03:12:47 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-07/</guid>
        <description>前言 书接上文，这次我们来聊聊剩下的几种类型转换 trait。 Borrow/BorrowMut 前文的 AsRef&amp;lt;T&amp;gt; 更像是简单的 T getter 逻辑。而 Borrow&amp;lt;T&amp;gt; 个人理解更多表述的是针对 T 类型的拓展，本质上是</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] 类型转换 trait 初见（一）</title>
        <link>https://saberuster.github.io/posts/rust-trait-06/</link>
        <pubDate>Wed, 17 Feb 2021 20:56:17 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Wed, 17 Feb 2021 20:56:17 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-06/</guid>
        <description>前言 虽然在 Rust 中提供了用于做基本类型转换的关键字 as，但是自定义类型也有类型转换的需求，所以 Rust 标准库为我们提供了一系列 trait 来解决这个问题。本篇文</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] std::ops 初见</title>
        <link>https://saberuster.github.io/posts/rust-trait-05/</link>
        <pubDate>Wed, 17 Feb 2021 20:54:46 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Wed, 17 Feb 2021 20:54:46 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-05/</guid>
        <description>前言 由于 ops 中的很多 trait 功能类似，所以就不一个一个来了。本篇文章以最短的篇幅概括 std::ops 中还未提及的主要知识点。 运算符重载 最基础的就是对四则运算之类的</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] Drop 初见</title>
        <link>https://saberuster.github.io/posts/rust-trait-04/</link>
        <pubDate>Tue, 16 Feb 2021 17:27:35 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Tue, 16 Feb 2021 17:27:35 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-04/</guid>
        <description>前言 在平时的开发中，我们可能需要利用析构函数来做一些收尾工作。在 Rust 中我们可以利用 Drop trait 来实现。本篇文章将会用最短的篇幅覆盖 Drop 的主要知识点。 impl Drop</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] Copy/Clone 初见</title>
        <link>https://saberuster.github.io/posts/rust-trait-03/</link>
        <pubDate>Tue, 16 Feb 2021 17:14:28 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Tue, 16 Feb 2021 17:14:28 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-03/</guid>
        <description>前言 Copy 作为能够影响编译器行为的 trait 对我们理解 Rust 基础有着重要作用，而 Clone 是我们作为搬砖工人能够自定义复制行为的 trait。本篇文章将会用最短的篇幅</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Std</category>
            
          
            
              <category>Programing</category>
            
          
            
              <category>Rust trait</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] (Partial)Ord/Eq 初见</title>
        <link>https://saberuster.github.io/posts/rust-trait-02/</link>
        <pubDate>Mon, 15 Feb 2021 08:42:43 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Mon, 15 Feb 2021 08:42:43 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-02/</guid>
        <description>前言 由于需要考虑全序关系（例如 Rust 浮点数中的 NaN），Rust 中有两套 trait 分别定义满足“全序”关系的 Ord/Eq 只能构成“偏序”关系的 PartialOrd</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Std</category>
            
          
            
              <category>Programing</category>
            
          
            
              <category>Rust trait</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>[Rust Std Trait] Default 初见</title>
        <link>https://saberuster.github.io/posts/rust-trait-01/</link>
        <pubDate>Sun, 14 Feb 2021 11:56:26 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Sun, 14 Feb 2021 11:56:26 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/rust-trait-01/</guid>
        <description>前言 本文致力于用最短的篇幅覆盖标准库中Default trait的主要知识点。 功能介绍 Default trait 可以用于定义类型的默认值。基础用法举例： 1 2 3 4 5 6</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>Rust</category>
            
          
            
              <category>Rust Std</category>
            
          
            
              <category>Programing</category>
            
          
            
              <category>Rust trait</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>UE4 中一种 Blueprint&amp;C&#43;&#43; 统一化接口的小技巧</title>
        <link>https://saberuster.github.io/posts/ue4-02/</link>
        <pubDate>Tue, 02 Feb 2021 04:55:01 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Tue, 02 Feb 2021 04:55:01 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/ue4-02/</guid>
        <description>问题描述 在ue4开发中本人之前一直有一种接口定义的困境，定义支持蓝图的接口吧在代码里用着不舒服，有点影响开发效率。定义只支持C++的接口吧蓝</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>折腾日记</category>
            
          
            
              <category>UE4</category>
            
          
            
              <category>动画</category>
            
          
            
              <category>C&#43;&#43;</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>在虚幻4中使用 Mixamo 的动画</title>
        <link>https://saberuster.github.io/posts/ue4-01/</link>
        <pubDate>Fri, 08 Jan 2021 18:38:20 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Fri, 08 Jan 2021 18:38:20 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/ue4-01/</guid>
        <description>前言 作为虚幻4的白嫖党，Mixamo 一定是不能错过的。本篇文章总结了 Mixamo 中动画迁移到虚幻4项目中的知识点。 导入基础骨架 Mixamo 中动画的骨架和虚幻4小</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>折腾日记</category>
            
          
            
              <category>UE4</category>
            
          
            
              <category>动画</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>【Houdini Tips】给输入设置默认几何体</title>
        <link>https://saberuster.github.io/posts/houdini-tips-01/</link>
        <pubDate>Sun, 03 Jan 2021 07:34:42 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Sun, 03 Jan 2021 07:34:42 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/houdini-tips-01/</guid>
        <description>在使用 Houdini 构建自己的 HDA 工具的时候经常会需要通过 Input 传入基础几何体信息。而我们又希望在无输入的情况下能有个默认值效果。经过几个 HDA 工具的开发，自己简</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>折腾日记</category>
            
          
            
              <category>Houdini</category>
            
          
            
              <category>3D美术</category>
            
          
            
              <category>Houdini Tips</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>将houdini procedural modeling加入自己的工作流</title>
        <link>https://saberuster.github.io/posts/houdini-01/</link>
        <pubDate>Mon, 23 Nov 2020 10:13:03 +0000</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Mon, 23 Nov 2020 10:13:03 +0000</atom:modified>
        <guid>https://saberuster.github.io/posts/houdini-01/</guid>
        <description>前言 本来近期想在blender里面做一小套场景拿到UE4里面测试一下光照和后期的。陆陆续续做了些场景内容后发现一个很让我头疼的问题：每次我想</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>折腾日记</category>
            
          
            
              <category>Houdini</category>
            
          
            
              <category>3D美术</category>
            
          
            
              <category>工具链</category>
            
          
        
        
        
      </item>
      
      <item>
        <title>使用hugo重建我的博客</title>
        <link>https://saberuster.github.io/posts/my-first-post/</link>
        <pubDate>Thu, 12 Nov 2020 12:47:01 +0800</pubDate>
        <author>saberuster@gmail.com (saberuster)</author>
        <atom:modified>Thu, 12 Nov 2020 12:47:01 +0800</atom:modified>
        <guid>https://saberuster.github.io/posts/my-first-post/</guid>
        <description>前言 依稀记得上次折腾自己的博客还是2018年。后来感觉无非就是写博客展示出来，啥平台都可以啊。所以之后又在零零散散几个能写文章的平台（例如知</description>
        
        <dc:creator>saberuster</dc:creator>
        
        
        
        
          
            
              <category>折腾日记</category>
            
          
        
        
        
      </item>
      

    
  </channel>
</rss>