[{"content":"前言  由于需要考虑全序关系（例如 Rust 浮点数中的 NaN），Rust 中有两套 trait 分别定义满足“全序”关系的 Ord/Eq 只能构成“偏序”关系的 PartialOrd/PartialEq。本文致力于用最短的篇幅覆盖标准库中Ord,Eq,PartialOrd,PartialEq的主要知识点。\nEq/PartialEq  Eq 和 PartialEq 在概念上的区别主要是否满足 a == a，乍看之下是句废话。实则不然，例如 a = NaN 就是特例。而在 trait 的定义上 Eq 是基于 PartialEq 的，Eq 自己更多是起修饰作用，在#[derive]中，PartialEq 在类型字段全部相等时为 true反之false，而 Eq 只是约束类型全字段也满足 Eq。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  externcratehello_rust;#[derive(Debug, Eq)]struct MyItem{id: i32,//... other Eq fields }implPartialEqforMyItem{fn eq(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; bool {self.id==other.id}}fn main(){letitem1=MyItem{id: 1};letitem2=MyItem{id: 1};assert_eq!(item1,item2);}   不难看出如果我们想用这套 trait，PartialEq 需要无脑怼上。需不需要 Eq 可以再考虑。\nOrd/PartialOrd  和前文一样，做这种区分就是因为一些特殊值例如 NaN \u0026lt; 0 == false 并且 NaN \u0026gt;= 0 == false。而在 trait 定义上 PartialOrd 基于 PartialEq 而 Ord 是 Eq + PartialOrd。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  usestd::cmp::Ordering;#[derive(Eq)]struct Person{id: u32,name: String,height: u32,}implPartialOrdforPerson{fn partial_cmp(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; Option\u0026lt;Ordering\u0026gt;{Some(self.cmp(other))}}implOrdforPerson{fn cmp(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; Ordering{self.height.cmp(\u0026amp;other.height)}}implPartialEqforPerson{fn eq(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; bool {self.height==other.height}}  总结  虽然上例演示使用了这套 trait，不过还是要说除 == 和 != 以外的其他运算符的语义都比较固定，适用范围有限，避免滥用。\n","description":"","id":0,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] (Partial)Ord/Eq 初见","uri":"https://saberuster.github.io/posts/rust-trait-02/"},{"content":"前言  本文致力于用最短的篇幅覆盖标准库中Default trait的主要知识点。\n功能介绍  Default trait 可以用于定义类型的默认值。基础用法举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #[derive(Debug)]struct TraitTest{enable: bool,type_id: i32,}implDefaultforTraitTest{fn default()-\u0026gt; Self{TraitTest{enable: true,type_id: 1,}}}fn main(){lettd=TraitTest::default();println!(\u0026#34;{:?}\u0026#34;,td);}  如果我们就是想用字段类型本身的默认值，不想像上面的例子一样指定特定值的话，用上面的写法明显会有大段的冗余代码。\n标准库已经为我们想到了：\n1 2 3 4 5 6 7 8 9 10  #[derive(Default, Debug)]struct TraitTest2{a: i32,b: bool,}fn main(){lettd2=TraitTest2::default();println!(\u0026#34;{:?}\u0026#34;,td2);}  这里需要注意的是在使用 #[derive] 的时候要确保类型的所有字段也都实现了 Default trait。\n一些基础类型在定义 Default trait 源码已经给他做实现了，所以我们可以直接用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /// default.rs 源码 macro_rules!default_impl{($t:ty,$v:expr,$doc:tt)=\u0026gt;{#[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]implDefaultfor$t{#[inline]#[doc = $doc]fn default()-\u0026gt; $t{$v}}}}default_impl!{(),(),\u0026#34;Returns the default value of `()`\u0026#34;}default_impl!{bool,false,\u0026#34;Returns the default value of `false`\u0026#34;}default_impl!{char,\u0026#39;\\x00\u0026#39;,\u0026#34;Returns the default value of `\\\\x00`\u0026#34;}default_impl!{usize,0,\u0026#34;Returns the default value of `0`\u0026#34;}/// ... 其他定义就省略了   在实践中我们经常会遇到一种情况：只想指定类型其中一个或几个字段的值。这种需求也有比较完美的解决方案：\n1 2 3 4 5 6 7 8  fn main(){lettd3=TraitTest{enable: false,..TraitTest::default()};println!(\u0026#34;{:?}\u0026#34;,td3);}  你可能觉得像上面一样在 TraitTest 里面用 TraitTest::default() 有点冗余。这个标准库也已经想到了(虽然目前还没stable)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #![feature(default_free_fn)]usestd::default::default;/// ... def code fn main(){lettd3=TraitTest{enable: false,..default()};println!(\u0026#34;{:?}\u0026#34;,td3);}  总结  虽然Rust比较复杂，但是真的用起来会发现不管是工具链还是代码书写总体来说是舒服的。尤其2019和2020年都已肉眼可见的速度变好。接下来我也会定期更一些Rust相关的基础文章为将来撸代码做准备。\n","description":"","id":1,"section":"posts","tags":["Rust","Rust Std","Programing"],"title":"[Rust Std Trait] Default 初见","uri":"https://saberuster.github.io/posts/rust-trait-01/"},{"content":"问题描述  在ue4开发中本人之前一直有一种接口定义的困境，定义支持蓝图的接口吧在代码里用着不舒服，有点影响开发效率。定义只支持C++的接口吧蓝图还要用。\n后来翻 GameplayAbility 插件的源码的时候发现人家的解决方案挺简单有效的，特此拿来借鉴一下。\n问题的解决方式 在 GameplayAbility 插件中定义了一个 IAbilitySystemInterface 接口，该接口只有一个普通的 C++ 纯虚函数。这种定义也是我们在代码里用着比较舒服的。缺点就是本身在蓝图中用不了。\n1 2 3 4 5 6 7  class GAMEPLAYABILITIES_API IAbilitySystemInterface { GENERATED_IINTERFACE_BODY() /** Returns the ability system component to use for this actor. It may live on another actor, such as a Pawn using the PlayerState\u0026#39;s component */ virtual UAbilitySystemComponent* GetAbilitySystemComponent() const = 0; };   为了支持蓝图，它的做法是在蓝图函数库中定义一个相同功能的静态函数：\n1 2  UFUNCTION(BlueprintPure, Category = Ability) static UAbilitySystemComponent* GetAbilitySystemComponent(AActor *Actor);   从蓝图侧传入Actor然后在代码里面判断Actor是否实现了接口，如果实现了直接调用接口，没有的话还可以通过遍历组件找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  if (Actor == nullptr) { return nullptr; } const IAbilitySystemInterface* ASI = Cast\u0026lt;IAbilitySystemInterface\u0026gt;(Actor); if (ASI) { return ASI-\u0026gt;GetAbilitySystemComponent(); } if (LookForComponent) { /** This is slow and not desirable */ ABILITY_LOG(Warning, TEXT(\u0026#34;GetAbilitySystemComponentFromActor called on %s that is not IAbilitySystemInterface. This slow!\u0026#34;), *Actor-\u0026gt;GetName()); return Actor-\u0026gt;FindComponentByClass\u0026lt;UAbilitySystemComponent\u0026gt;(); } return nullptr;   个人感觉这种方式比直接在接口文件中直接定义蓝图可用的接口灵活很多。\n","description":"","id":2,"section":"posts","tags":["折腾日记","UE4","动画","C++"],"title":"UE4 中一种 Blueprint\u0026C++ 统一化接口的小技巧","uri":"https://saberuster.github.io/posts/ue4-02/"},{"content":"前言  作为虚幻4的白嫖党，Mixamo 一定是不能错过的。本篇文章总结了 Mixamo 中动画迁移到虚幻4项目中的知识点。\n导入基础骨架  Mixamo 中动画的骨架和虚幻4小白人是不一样的，如果我们直接把动画导入进引擎我们小白人也用不了。解决方案就是把 Mixamo 中那套通用的骨架先导入进引擎，然后再在引擎中把动画 retarget 到小白人的骨架上。\n 因为我们要导入的骨架其实就是做个中间层，不需要乱七八糟的贴图材质啥的，所以我就选择了 Mixamo 中的 YBot 角色，因为它比较干净。这里要注意导出的时候要选 T Pose。\n然后将其导入引擎。之后我们从 Mixamo 中导出的所有动画在导入引擎的时候都选择这个骨架就可以了。\n类人绑定  为了能够把动画转到小白人上我们需要将骨架进行类人绑定。这是虚幻4中的一个现成的功能，只需要自己配置一下。\n小白人自己的骨架知道让系统自动绑定就行了。主要就是上面提到的 Mixamo 的基础骨架。因为它和小白人骨架的差别较大需要自己耐心一个一个调一调。\n 完成之后需要在骨骼的那个树状图的 Option 中开启 retarget options 显示。然后把除了 Hips 以外的所有骨骼设置成skeleton（默认是 Animation）。\n把小白人设置成 T Pose  小白人默认是 A Pose。为了能够迁移我们需要手动把他调成 T Pose 的。直接再骨骼界面旋转调整，满意后点击 retarget manager 页面的 ModifyPose，选择 Current Pose 即可。\n开始迁移动画  完成上面的操作我们就可以快乐的把 Mixamo 中的动画给小白人用啦！想迁移单个动画就在动画序列上右键然后 retarget。要是想一次迁移全部就直接在骨骼上右键retarget就可以了。\n参考索引(需要翻墙) ","description":"","id":3,"section":"posts","tags":["折腾日记","UE4","动画"],"title":"在虚幻4中使用 Mixamo 的动画","uri":"https://saberuster.github.io/posts/ue4-01/"},{"content":" 在使用 Houdini 构建自己的 HDA 工具的时候经常会需要通过 Input 传入基础几何体信息。而我们又希望在无输入的情况下能有个默认值效果。经过几个 HDA 工具的开发，自己简单总结成了以下两步：\n利用 switchif 做默认值切换  这里选择 switchif 而不是 switch 是因为 switchif 是在 0 和 1 之间切换，而 switch 可以不止两个输入。在节点的表述性上更加直观。其次 switchif 内置选项中集成了 npoints 功能（虽然手写个表达式就多敲7个字母的问题而已，不过等节点多起来脑子要判断这个框里写的啥还是要想一下）。\n switchif 需要注意两点：节点选择 0 还是 1 分别对应断言的 false 和 true，与断言语义无关。还可以利用 spare input 将非输入节点引入断言。\n利用 disable when 禁用默认配置  在连接了 Input 以后我们希望能够把默认配置的选项都禁用掉，这时就需要用到 disable when 的语法:\n这里的语法在官方文档有比较全面的参考\n示例 HDA 下载地址\n ","description":"","id":4,"section":"posts","tags":["折腾日记","Houdini","3D美术","Houdini Tips"],"title":"【Houdini Tips】给输入设置默认几何体","uri":"https://saberuster.github.io/posts/houdini-tips-01/"},{"content":"前言  本来近期想在blender里面做一小套场景拿到UE4里面测试一下光照和后期的。陆陆续续做了些场景内容后发现一个很让我头疼的问题：每次我想在Mesh上改点什么都需要把之后展UV，LowPoly，HighPoly，各种贴图烘焙等整个流程全部都走一遍。作为一名非专业3D美术技术人员，我并没有找到什么好的办法来解决这个问题。然而对于我来讲每天的工作内容很多，不可能在这上面浪费太多时间，所以我重拾起了电脑里面快半年没打开的houdini打算利用它来搞定这个需求。经过两天的研究初步总结出了一套适用于我个人的3D美术资产的pipline:\nblender打Mesh草稿-\u0026gt;去houdini里面创建HDA进行程序生成和参数化-\u0026gt;利用Gamedev插件做贴图烘焙和fbx导出或者直接利用houdini engine直接把HDA怼到引擎里面\n PS:其实Blender利用UE4官方的SendToUnreal插件也能直接把Mesh怼到引擎里面预览，减轻了Mesh导入导出的成本，不过在blender端修改Mesh的工作量还是没有减少。所以我目前觉得SendToUnreal更多的是作为引擎多边形编辑工具的拓展，重点在我上面的打Mesh草稿阶段，对整个美术资产制作流程的优化作用有限。\n关于 procedural modeling 的思考  不断完善自己工具链的过程也是明确自身需求的过程。就我个人而言因为美术功底和艺术上的创造力近乎于无，最多就是去artstation上找找灵感，然后到处翻教程。所以本身无法在这个方向获得足够的竞争力。而相比之下鄙人在编程上面相对擅长一些，所以我是更能够接受把程序化建模引入工作流并不断优化，同时放弃一些美术上自由度的方案。\nDemo示例 下面通过一个蒸笼的模型来演示一下整个流程：\n 首先创建一个叫“steamer”的HDA。然后将其划分为4部分：\n body 是蒸笼的主体，主要就是一个Tube在两边挤出然后利用polybridge掏空中间。    grid 是蒸笼每一层的网格底。\n就是简单的矩形变换然后和上面body的BaseTube做布尔运算切出需要的部分，就不上图了。\n  cap 是蒸笼的顶部原型盖子。\n  盖子部分我的做法是把一个平面投射到球体上，然后通过调整球体Y轴的半径来控制盖子的弧形感觉。\n关于UV的小技巧  虽然我们的模型面数很少，不过如果我们频繁HDA参数调整模型的拓扑结构，autouv所消耗的时间还是很多的，直观的感受就是电脑会卡一下。所以一般会在HDA的参数中添加一个启用UV的参数然后在switch节点中通过取值0或1来开关UV的自动展开。这样我们在频繁调整的时候就不会卡了。\n 程序化建模对于新手来说最需要注意的一点就是对于UV空间的重复利用。例如像我们的蒸笼模型中，我们的蒸笼主体其实就是一个蒸笼格子一个个往上摞。所以他们完全可以公用同一块UV空间。当然这并不是完全没有问题的，如果你需要在某个格子上添加特殊的细节的话这种公用方案就无法满足。还有一点就是在UE4里面光照贴图要求UV之间是不能重叠的。不过这个其实引擎已经帮我们想到了，在我们把模型导入引擎的时候，引擎默认会帮我们生成一套专门的用作光照相关的UV(当然我们自己生成也可以)。就像我之前所说的，目前来讲“在某个格子上添加特殊的细节”这种操作并不能在美术上让我更有竞争力，所以我选择放弃这一点自由度换取数字资产在管线和效率上的优势。\n导出fbx以及烘焙各种贴图  houdini对我们常用的fbx和各种贴图的支持也是很好的。其中fbx导出没什么可说的，大家都一样。关于贴图的烘焙我们可以通过Gamedev（SideFxLabs）的插件里的maps backer来完成。\n我们可以看到在maps backer中我们常用的几种例如法线贴图，Curature贴图，AO贴图等等都支持。\n我们在用SP的烘焙的时候有一个选项就是OnlyByMeshName的选项。而在houdini中我们可以通过在烘焙前利用align and distribute节点让不同名称的Mesh分开依次间隔排列，这样就达到了和OnlyByMeshName相同的效果。\n展望  之前还接触过PDG相关的东西，不过目前来讲自己还没有这种需求，如果以后有机会我还是愿意试试的。随着技术的发展各个细分领域都可能会出现或者已经存在更加专业的解决方案，很难再出现一个工具cover所有需求的情况。那么多关注自身工具链的构建将各种解决方案有机的结合起来在当下就成了一件很重要的事情。\n","description":"","id":5,"section":"posts","tags":["折腾日记","Houdini","3D美术","工具链"],"title":"将houdini procedural modeling加入自己的工作流","uri":"https://saberuster.github.io/posts/houdini-01/"},{"content":"前言  依稀记得上次折腾自己的博客还是2018年。后来感觉无非就是写博客展示出来，啥平台都可以啊。所以之后又在零零散散几个能写文章的平台（例如知乎）更新过一些文章。直到有一天我遇见了redblobgames，里面的文章有很多能交互的东西让人对文章的内容有更深的理解。本着“我也想这样”的本能开启了这次的折腾的不归路。\n关于为什么选择Hugo  主要因为自己本身对Golang比较熟悉所以选择了Hugo。万一拓展点什么功能说不定还能贡献点代码参与参与开源社区。\n博客的主要内容  2018年的时候其实对自己的认知还是一个纯码农。所以更多的关注的是自己感兴趣的一些技术趋势。后来发现能安心做个我心目中的超级码农和当科学家一样是一个门槛奇高无比的事情。因为我觉得当今的软件开发的技术迭代我觉得已经超越了个人能承受的极限，所以想在保证本职专业度的前提下再拓展自己新的认知领域是一件很难的事情，除非能做到站在更高的认知上俯瞰技术的发展。2年过去了，我选择对自己的定位做出一定调整哈哈，超级码农对我来说还是有点不太现实。\n扯了点别的，回到主题博客内容按我目前的构想主要还是先以编程技术为主，之后再包含一些自己折腾各种游戏设计，3D美术相关东西的心得吧，也借此让自己更加多元化一点。\n说好的交互内容呢  博客先支个摊出来熟悉熟悉代码，目前计划先拿个主题先顶着，以后先换个自己的主题然后开始折腾交互内容。\n最后 希望这次能够坚持下来吧!!! ","description":"","id":6,"section":"posts","tags":["折腾日记"],"title":"使用hugo重建我的博客","uri":"https://saberuster.github.io/posts/my-first-post/"},{"content":"这个人很内向，还没想好如何介绍自己。\n","description":"一个喜欢编程和折腾的追风少年","id":7,"section":"","tags":null,"title":"关于我","uri":"https://saberuster.github.io/about/"}]