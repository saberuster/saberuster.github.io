[{"content":"前言  很早之前就听说过 \u0026laquo;地球编年史\u0026raquo; 的大名，不过一直没有机会沉下心来研读此书。因为个人的工作转变，需要吸取养分进行内容创作，于是就想起了这套书籍。\n 比较重要的一点，本书内容过于宏大，横跨各个学科，对于个人来讲很难一一考证当中的虚实真伪。我会将其仅做为科幻的参考读物。\n本章的主要内容  由“生命源头在哪里？”，“人类究竟怎么进化的？” 两个问题引申出作者对人类突然的“进步”的质疑。\n我整理了书中提到的几个质疑生命来源的点：\n 按进化论的思路地球上不应该只有一种生命形式（我猜说的应该是“碳基生命”） 生命体内的化学元素都是地球上比较稀缺的元素  还有几个质疑进化论的点：\n 进化在历史的长河中一直是一个无比缓慢的过程，而“智人”的出现相比这个缓慢的过程而言更像是突然出现的 当代的世界上有各种原始部落，如果遵循进化论为什么这些原始人没有技术突破，形成现代社会  书中还引用了一个观点：“现代人有许多近亲和分支，但是没有祖先”。\n人类文明发展的里程碑是农业的产生。\n农业产生前的阶段是旧石器时代，农业产生后的阶段是中石器时代，陶器以后叫做新石器时代。\n本章还提出了之后故事的重点发源地”近东“，就是我们上学时候学习到的幼发拉底河和底格里斯河流域。\n","description":"","id":0,"section":"notes","tags":null,"title":"【随笔】地球编年史(一)无尽的起源","uri":"https://saberuster.github.io/notes/book01-01/"},{"content":"在我个人的技术栈中 Rust 在适用广度上比其他语言更像 C++。所以前段时间坚持更新一段时间的 Rust 基础，把一些基本的知识点全都过了一遍(还有一些比较复杂的例如协变和逆变暂未涉及)。在未来主要还是更新两大类内容，因为不久之后 UE5 的预览版源码就要发布了，所以计划先更新一些 Unreal 的源码 Tips，等 UE5 源码放出来了计划做一个源码入门的系列文章。Rust 方面我计划以 Bevy 引擎为基础更新实战分析类的文章，一方面夯实 Rust 基础，一方面也是伴随一个新兴引擎的成长，对整个现代引擎有更深的理解。\n","description":"","id":1,"section":"posts","tags":null,"title":"未来一段时间博客内容的一些思考","uri":"https://saberuster.github.io/posts/dairy-01/"},{"content":"前言  前段时间摸鱼更了点 Rust 的基础，今天开始回归正途。其实 Unreal 相关的源码解析文章大佬们已经写过很多了，而且都很深入。这也导致像我这样的萌新看了心里感觉很厉害，但是一到自己的手头的工作好像还是不知所措。所以我计划开一个专门针对有编程基础的萌新版的源码解析系列。专注承上启下，既能对手头的东西有帮助又能帮助各位理解大佬们的文章到底在写些什么。本系列也是我的一次尝试未必成功，有好的建议欢迎联系我。\n公众号：\nQQ群:\n","description":"","id":3,"section":"posts","tags":null,"title":"[Unreal源码系列]前言","uri":"https://saberuster.github.io/posts/unreal-src-01/"},{"content":"图形渲染模块都在 Graphics 文件夹中\n模型相关  Model.cs ModelAnimation.cs ModelRenderer.cs  演示相关  Pallete.cs PaletteReference.cs  地图渲染  WorldRenderer  Sprite 渲染 ","description":"","id":4,"section":"notes","tags":null,"title":"[随笔]OpenRA 图形模块","uri":"https://saberuster.github.io/notes/openra-03/"},{"content":"FileSystem 做上层调用的管理类，\nFileSystem 管理底层的 package\n一个package 可以拥有多个文件。\nPackage 当前有两个实现，Zip 和 文件夹。\n缓存是用文件名做key返回所有包含其的package\nfileindex\n","description":"","id":5,"section":"notes","tags":null,"title":"[随笔]OpenRA 文件模块","uri":"https://saberuster.github.io/notes/openra-02/"},{"content":"前言  最近听闻 Rust 社区要做 OpenRA 的 rust 版本，我也想借此机会提升一下自己在 Rust 和引擎架构上的知识。计划每天花一点点时间看一点源码，写写笔记。如果有机会混混 PR。最开始不会太深入具体，目的是把项目代码的脉络理清。作为随笔系列，主要就是看到什么写点什么，文章没什么设计，不成体系，单纯的就是“随笔”。\nOpenRA.Server 是服务端的启动代码，主要就是从命令行接收参数。Game.InitializeSettings 将参数传入。\nvar server = new Server(endpoints, settings, modData, ServerType.Dedicated); 在初始化Server 的时候会开新线程进行主 Loop。\n然后主线程最后每隔 1 秒检查游戏状态。\nOpenRA 定义了一堆 trait， ITick trait 代表需要 Tick 的对象。\n结语 感觉这个源码还是挺适合学习的。代码比较简洁明了，Unreal 的源码光 Tick 的分组和 Tickable 的分类就已经七七八八一堆代码了，不容易理解整体脉络。\n","description":"","id":6,"section":"notes","tags":["OpenRA","随笔"],"title":"[随笔]OpenRA 源码（一）Server 启动与主循环Tick","uri":"https://saberuster.github.io/notes/openra-01/"},{"content":"前言  经过两天的折腾利用 blender 完成了一个小的45度场景练习。主要目的是为了踩坑和增加场景的制作效率。\n最终结果图：\n经验  利用 blender 自带的布尔工具插件进行造型。\n利用 需要做穿插的地方可以选择凹陷来避免穿插在明面上\n太单调的地方可以做一些变化，避免场景太平。\n不足 blender 2.92 新出的快速创建几何体的 primitive add tool 的使用。\n渲染出图的降噪还没好的方法。\n未导入虚幻4进行渲染。\n","description":"","id":7,"section":"posts","tags":null,"title":"Blender Basic 01","uri":"https://saberuster.github.io/posts/blender-basic-01/"},{"content":"前言  本文主要覆盖闭包的基础知识点。\n基本语法 1  letadd=|a:i32,b:i32|-\u0026gt;i32 {returna+b;};  闭包的返回值和参数类型是可以省略的：\n1  letadd=|a,b|{returna+b;};  和普通函数一样，最后的 return 也可以省略：\n1  letadd=|a,b|{a+b};  如果只有一条语句大括号也可以省略：\n1  letadd=|a,b|a+b;  变量捕获 Rust 中默认变量捕捉是根据使用自动选择捕捉形式。一般可以理解为 3 种：\u0026amp;T，\u0026amp;mut T。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  struct T(i32);fn by_value(_: T){}fn by_mut(_: \u0026amp;mutT){}fn by_ref(_: \u0026amp;T){}fn main(){letx=T(1);lety=T(2);letmutz=T(3);letclosure=||{by_value(x);by_ref(\u0026amp;y);by_mut(\u0026amp;mutz);};closure();}  有时闭包的生命周期会超过原本的函数范围：\n1 2 3 4 5 6 7 8 9 10  fn return_closure_error()-\u0026gt;implFn()-\u0026gt;i32 {leta=1;||a// error }fn return_closure()-\u0026gt;implFn()-\u0026gt;i32 {leta=1;move||a}  对于这种情况我们可以使用 move 关键字全部通过 by value 方式捕捉。\n不过细究之下还会有个小问题：\n1 2 3 4 5 6 7  fn main(){letc=3;letadd=|a|move|b|a+b+c;println!(\u0026#34;{}\u0026#34;,add(1)(2));}  我们不想通过 by value 的形式捕捉 c 怎么办呢？其实只要用 by value 形式捕获 c 的引用就可以了：\n1 2 3 4 5 6 7  fn main(){letc=\u0026amp;3;letadd=|a|move|b|a+b+c;println!(\u0026#34;{}\u0026#34;,add(1)(2));}  这种情况可能在上例中有点无病呻吟的意思，不过结合多线程的场景就能理解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  usestd::sync::Arc;usestd::thread;fn main(){letstates: Vec\u0026lt;_\u0026gt;=(0..10i32).collect();letshared_states=Arc::new(states);for_in0..10{letshared=shared_states.clone();thread::spawn(move||{let_=\u0026amp;shared;});}}  我们肯定不希望直接把状态的所有权直接转移进特定线程，所以可以变通一下搞一个线程安全的 Arc 引用数据，然后 clone 它把它传进去。\n","description":"","id":8,"section":"posts","tags":null,"title":"[Rust 基础知识]闭包","uri":"https://saberuster.github.io/posts/rust-basic-08/"},{"content":"前言  本文主要包含动态分派和静态分派的主要知识点。\n静态分派  静态分派就是指程序具体调用哪个函数在编译阶段就能确定下来。Rust 中可以通过泛型和 impl trait 来完成静态分派。泛型我们之前已经做个介绍，这里就不赘述了。主要讲讲 impl trait。\n 在我们使用泛型的时候，如果想返回复杂的迭代器类型或者匿名的闭包会很难受。这时我们就可以通过 impl trait 解决：\n1 2 3  fn returns_closure()-\u0026gt; implFn(i32)-\u0026gt; i32 {|x|x+1}  该语法目前还能使用在参数列表中：\n1 2 3  fn in_fn(f: implFn(i32)-\u0026gt; i32){f(1);}  虽然官方说还会增加更多的使用场景，不过个人发现有用的就是这么几种情况。因为很难有自定义类型只靠单独一两种 trait 描述，所以实际使用时很容易写出 impl XXX + Clone + XXX + XXX ... 一连套的东西，可读性依然很低。所以目前看它主要还是为了解决特定问题而存在。\ntrait object 与动态分派  trait object 指的是指向 trait 的指针。例如 MyTrait 的 trait object 可以是：\u0026amp;dyn MyTrait,\u0026amp;mut dyn MyTrait,Box\u0026lt;dyn MyTrait\u0026gt;,*const dyn MyTrait,*mut dyn MyTrait, Rc\u0026lt;dyn MyTrait\u0026gt; 等等。\n当我们把 trait 当作类型的时候我们无法在编译期知道它的大小，属于动态类型（DST）。我们可以把 trait object 理解为：\n1 2 3 4  struct TraitObject{data: *mut(),vtable: *mut()}  Rust 里面类型本身不包含虚函数表的指针，而是位于各个 trait object 里面。这也就意味着相同的类型的不同 trait object 的虚函数表也不一样。\n借用这个特性我们可以完成一个经典应用场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  traitTickable{fn tick(\u0026amp;self,delta_time: f32);}struct A{}struct B{}implTickableforA{fn tick(\u0026amp;self,delta_time: f32){println!(\u0026#34;A tick!\u0026#34;)}}implTickableforB{fn tick(\u0026amp;self,delta_time: f32){println!(\u0026#34;B tick!\u0026#34;)}}fn main(){letmutcomponents: Vec\u0026lt;Box\u0026lt;dynTickable\u0026gt;\u0026gt;=Vec::new();components.push(Box::new(A{}));components.push(Box::new(B{}));components.iter().for_each(|c|c.tick(1.0));}  object safety  为了保证动态分派不会出问题，我们需要对能够动态分派的 trait 做一些限制。例如如果我们动态分派 Clone trait 就会出问题，我们不知道克隆出来的到底是什么类型。例如：\n1 2 3 4 5 6 7  traitSomeTrait{fn foo(\u0026amp;self)-\u0026gt; int{...}// Object-safe methods may not return `Self`: fn new()-\u0026gt; Self;}  new 和 Clone 有同样的问题。为此 Rust 目前提供两种解决方案，一种是拆分 trait：\n1 2 3 4 5 6 7 8  traitSomeTrait{fn foo(\u0026amp;self)-\u0026gt; int{...}}traitSomeTraitCtor: SomeTrait{fn new()-\u0026gt; Self;}  另一种就是加 Self::Sized:\n1 2 3 4 5 6  traitSomeTrait{fn foo(\u0026amp;self)-\u0026gt; int{...}fn new()-\u0026gt; SelfwhereSelf: Sized;// this condition is new }  所以我们也能理解源码里面 Clone trait 为啥要继承 Sized 约束了：\n1 2 3 4 5  #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]#[lang = \u0026#34;clone\u0026#34;]pubtraitClone: Sized {// ... }  ","description":"","id":9,"section":"posts","tags":["Rust","Rust Edition Guide","Programing"],"title":"[Rust 基础知识]动态分派和静态分派","uri":"https://saberuster.github.io/posts/rust-basic-07/"},{"content":"前言  模式结构是写 Rust 代码中最常用到的设计。本文主要关注模式解构的相关知识点。\n一般形式 模式解构可以用在：\n let 声明 函数和闭包的参数列表 match 表达式 if let 表达式 while let 表达式 for 表达式  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  struct T{iterm1: i32,iterm2: i32,}fn test_fn((a,b): (i32,i32)){println!(\u0026#34;{} {}\u0026#34;,a,b);}fn main(){lettuple=(1i32,2i32);let(first,second)=tuple;letcallable=|(a,b): (i32,i32)|{println!(\u0026#34;{} {}\u0026#34;,a,b);};println!(\u0026#34;{} {}\u0026#34;,first,second);test_fn(tuple);callable(tuple);lett=T{iterm1: 1,iterm2: 2,};letT{iterm1: i1,iterm2: i2,}=t;println!(\u0026#34;{} {}\u0026#34;,i1,i2);letT{iterm1: ii1,..}=t;println!(\u0026#34;{}\u0026#34;,ii1);leta=1i32;matcha{0..=1=\u0026gt;println!(\u0026#34;a = 1\u0026#34;),_=\u0026gt;println!(\u0026#34;default\u0026#34;),}letb=Some(1);ifletSome(num)=b{println!(\u0026#34;num = {}\u0026#34;,num)}letarr=vec![1,2,3];for(index,val)inarr.iter().enumerate(){println!(\u0026#34;{} =\u0026gt; {}\u0026#34;,index,val);}}  match 在使用 match 需要覆盖该类型的所有情况，即使可能只有部分值有合法意义例如：\n1 2 3 4 5 6 7  lett=1;// 1 2 3 有效 matcht{1=\u0026gt;println!(\u0026#34; is 1\u0026#34;),2=\u0026gt;println!(\u0026#34; is 2\u0026#34;),3=\u0026gt;println!(\u0026#34; is 3\u0026#34;),_=\u0026gt;println!(\u0026#34; is default\u0026#34;),}  我们只需要 1 2 3 但是也需要利用 _ 囊括所有情况才能通过编译。所以如果只是需要一个分支可以使用 if let。\nGuards 在 match 中的判定条件还能继续细分：\n1 2 3 4 5 6 7  fn main(){lett=1;// 1 2 3 有效 matcht{iifi\u0026gt;2=\u0026gt;println!(\u0026#34; bigger than 2\u0026#34;),_=\u0026gt;println!(\u0026#34; is default\u0026#34;),}}  变量绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  fn main(){lett=Some(Some(3));// 1 2 3 有效 matcht{Some(r@Some(1..=3))=\u0026gt;println!(\u0026#34;{:?}\u0026#34;,r),_=\u0026gt;println!(\u0026#34; is default\u0026#34;),}letmutx: Option\u0026lt;String\u0026gt;=Some(\u0026#34;hello\u0026#34;.into());match\u0026amp;mutx{Some(s)=\u0026gt;s.push_str(\u0026#34;world\u0026#34;),None=\u0026gt;println!(\u0026#34;none\u0026#34;),}println!(\u0026#34;{}\u0026#34;,x.unwrap())letx=5i32;matchx{refr=\u0026gt;println!(\u0026#34;{}\u0026#34;,r),}letmuty=6i32;matchy{refmutr=\u0026gt;*r=5i32,}println!(\u0026#34;{}\u0026#34;,y)}  ","description":"","id":10,"section":"posts","tags":["Rust","Rust Edition Guide","Programing"],"title":"[Rust 基础知识]模式解构","uri":"https://saberuster.github.io/posts/rust-basic-06/"},{"content":"前言  本文囊括 Rust 中泛型的主要知识点。\n泛型的一般形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  enum MyOption\u0026lt;T\u0026gt;{Some(T),None,}struct Num\u0026lt;T=i32\u0026gt;{data: Option\u0026lt;T\u0026gt;}fn test_fn\u0026lt;T\u0026gt;(param: T)-\u0026gt; bool fntest_fn\u0026lt;T,U\u0026gt;(param: T,param2: U)-\u0026gt; bool impl\u0026lt;T,U\u0026gt;Into\u0026lt;U\u0026gt;forTwhereU: From\u0026lt;T\u0026gt;{fn into(self)-\u0026gt; U{U::from(self)}}  泛型参数约束 Rust 中有两种方法给泛型参数添加约束：\n第一种通过冒号指定：\n1  fn max\u0026lt;T: PartialOrd\u0026gt;(a: T,b: T)-\u0026gt; T{}  第二种使用 where 子句指定：\n1 2  fn max\u0026lt;T\u0026gt;(a: T,b: T)-\u0026gt; TwhereT: PartialOrd   一般简单约束可以用冒号，复杂的用 where 子句。我们可以理解冒号用法都能转换成 where 子句，反之并不能。\n1 2  fn max(self)whereSelf: Sized   类似上例这种就无法用冒号代替。\n关联类型 trait 中不仅可以包含方法和常量，还可以包含类型。这种类型叫做关联类型。\n1 2 3  pubtraitMyType{type MyInnerType;}  一个使用它的经典场景就是在泛型中约束特定元素的迭代器：\n1 2 3  fn test_fn(mutiter: ITER)whereITER: Iterator,ITER::Item: Debug  关联类型和普通的泛型参数在功能上有重叠，一般在选择时主要关注类型是否需要这个 trait 多次，例如 AsRef 我们就可以实现多次，因为我们可以 AsRef 成不同的类型。\n而像 Deref 这种肯定更希望只实现一次，这时就可以考虑关联类型。\n泛型特化 特化的三个意义：\n 性能优化：针对统一抽象的特殊场景做特殊处理 代码重用：提供默认实现，有时能减少代码 作为 trait 系统“高效继承”的基础  具体的以后单开再聊。\n","description":"","id":11,"section":"posts","tags":["Rust","Rust Edition Guide","Programing"],"title":"[Rust 基础知识]初探泛型","uri":"https://saberuster.github.io/posts/rust-basic-05/"},{"content":"前言  生命周期标记主要用来处理生命周期跨函数时的情况。\n标记形式 生命周期标记的一般形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026amp;i32// a reference \u0026amp;\u0026#39;ai32// a reference with an explicit lifetime \u0026amp;\u0026#39;amuti32// a mutable reference with an explicit lifetime fn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;astr,y: \u0026amp;\u0026#39;astr)-\u0026gt; \u0026amp;\u0026#39;astrfn foo\u0026lt;\u0026#39;a,\u0026#39;b\u0026gt;(x: \u0026amp;\u0026#39;ai32,y: \u0026amp;\u0026#39;bi32)struct ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt;{part: \u0026amp;\u0026#39;astr,}fn longest_with_an_announcement\u0026lt;\u0026#39;a,T\u0026gt;(x: \u0026amp;\u0026#39;astr,y: \u0026amp;\u0026#39;astr,ann: T,)-\u0026gt; \u0026amp;\u0026#39;astr  生命周期参数都有撇号（'）作为前缀。如果标记的是引用，放在 \u0026amp; 后面。这个标记只起到修饰作用，不会影响参数的生命周期，可以理解为给编译器识别用的。\n生命周期标记的一大用途就是显式声明包含关系。例如：\n1  \u0026#39;a:\u0026#39;b  表示 \u0026lsquo;a 的生命周期一定大于等于 \u0026lsquo;b 的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  externcratehello_rust;fn foo\u0026lt;\u0026#39;a,\u0026#39;b\u0026gt;(x: \u0026amp;\u0026#39;ai32,y: \u0026amp;\u0026#39;bi32)-\u0026gt; \u0026amp;\u0026#39;ai32where\u0026#39;a: \u0026#39;b,{println!(\u0026#34;x={} y={}\u0026#34;,x,y);x}fn main(){letnum1: i32 =1;letmutnum1_ref=\u0026amp;num1;{letnum2: i32 =2;letmutnum2_ref=\u0026amp;num2;num1_ref=foo(num1_ref,num2_ref);}println!(\u0026#34;{:?}\u0026#34;,num1_ref);}  在上例中，如果把 foo 的返回值的生命周期标记改为 \u0026lsquo;b ，程序将会报错，因为函数标记的返回值生命周期和 \u0026lsquo;b 相同，而 num1_ref 超出了这个范畴。\n再看一个结构体的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #[derive(Debug)]struct Type\u0026lt;\u0026#39;a\u0026gt;{index: \u0026amp;\u0026#39;ai32,}fn main(){leti=0;letmutt=Type{index: \u0026amp;i};{leti2=1;t.index=\u0026amp;i2;}println!(\u0026#34;{:?}\u0026#34;,t);}  结构体通过标记 \u0026lsquo;a 要求作为 Type 的字段 \u0026amp;i32 来说，\u0026amp;i32 至少要和 Type 的生命周期一样长。而本例中 i2 明显生命周期短于 t，所以程序就会报错。\n通过上面两个例子相信对于生命周期标记的职责已经有了一定了解。传通过统的代码语言有时很难表述出这种关系，只能留给程序员自己维护，在复杂的软件中这种生命周期问题一旦遇到往往很难排查。Rust 并没有增加问题，只是增加了一种解决问题的方式。\n特殊的 static  生命周期标记中有个特殊值 \u0026lsquo;static，它表示程序从开始到结束的整个生命周期。所以对于任意生命周期 \u0026lsquo;a 永远有 \u0026lsquo;static : \u0026lsquo;a。\n生命周期标记的省略  生命周期标记很重要，但是如果所有需要的地方我们都要手动标记的话怕不是要累死人了。所以生命周期标记可以省略：\n1 2  fn first_word\u0026lt;\u0026#39;a\u0026gt;(s: \u0026amp;\u0026#39;astr)-\u0026gt; \u0026amp;\u0026#39;astr{fn first_word(s: \u0026amp;str)-\u0026gt; \u0026amp;str   省略的生命周期标记不会有复杂的自动推导过程，除了上例外只有三条简单的规则：\n第一条：对于输入参数一人分配一个生命周期标记。\n1 2  fn foo\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;ai32)// fn foo(x:i32) fn foo\u0026lt;\u0026#39;a,\u0026#39;b\u0026gt;(x: \u0026amp;\u0026#39;ai32,y: \u0026amp;\u0026#39;bi32)// fn foo(x:i32, y:i32)   第二条：如果只有一个输入参数指定了生命周期标记，那么将它应用于所有返回参数。\n第三条：如果多个输入参数制定了生命周期标记，但是存在 \u0026amp;self 或者 \u0026amp;mut self，所有返回参数应用 self 的标记。\n其他情况需要手动标记。\n","description":"","id":12,"section":"posts","tags":["Rust","Rust Edition Guide","Programing"],"title":"[Rust 基础知识]初探生命周期标记","uri":"https://saberuster.github.io/posts/rust-basic-04/"},{"content":"前言  本文以最短篇幅概括借用和借用规则的相关知识点。\n借用  在 Rust 中，变量除了可以直接进行所有权转移，还可以借用。借用分为两种：只读借用（\u0026amp;），和读写借用（\u0026amp;mut）。所谓的借用和指针更多的是语义上的区别，标记该借用来的指针对内存没有“所有权”。“借用”概念是在编译阶段的静态检查中起作用。\n需要弄清的是 mut 在不同场景下的意义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  struct T{index: i32,}fn test_fn(param1: \u0026amp;T,param2: \u0026amp;mutT,param3: \u0026amp;T){// param2 参数需要可变引用 ifparam3.index\u0026gt;0{param2.index=param1.index;}}fn main(){lettp=T{index: 1};letmuttp2=T{index: 0};// tp2 是可变的 letmuttp3=T{index: 3};// tp3 是可变的 test_fn(\u0026amp;tp,\u0026amp;muttp2,\u0026amp;tp3);// 读写借用可变变量 tp2 只读借用可变变量 tp3 }  当修饰 Self 时：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  struct T{index: i32,}implT{fn test_self_fn(\u0026amp;self){println!(\u0026#34;test self fn\u0026#34;);}fn test_mut_self_fn(\u0026amp;mutself){println!(\u0026#34;test mut self fn\u0026#34;);}}fn main(){lettp=T{index: 1};letmuttp2=T{index: 0};tp.test_self_fn();//tp.test_mut_self_fn(); // 只有被 mut 修饰的变量才能调用 \u0026amp;mut self 的函数 tp2.test_self_fn();tp2.test_mut_self_fn();}  在 Rust 中还有一种叫做切片（Slice）的类型，利用它能够引用集合中的一段连续序列，而不是整个集合。\n1 2 3 4 5 6 7  fn main(){letstr1=String::from(\u0026#34;abcdefghijklmn\u0026#34;);letc1=[1,2,3,4,5,6];println!(\u0026#34;{}\u0026#34;,\u0026amp;str1[..3]);println!(\u0026#34;{:?}\u0026#34;,\u0026amp;c1[1..2]);}  需要注意字符串切片是按 byte 分的，以后再单开文章讲 utf8 字符串的处理。\n借用规则  既然整出了个借用的概念，那么肯定就有对应的约束规则。\n第一点：引用必须是有效的。最经典的反面例子就是返回局部变量的引用。\n1 2 3 4  fn dangle()-\u0026gt; \u0026amp;String {lets=String::from(\u0026#34;hello\u0026#34;);\u0026amp;s}  第二点：在同一时间只允许有一个可变引用或者多个只读引用。这里需要注意的是这里讲的是有效代码：\n1 2 3 4 5 6 7 8 9  fn main(){letmutstr1=String::from(\u0026#34;adasdsa\u0026#34;);letstr2=\u0026amp;mutstr1;letstr3=\u0026amp;str1;str1+=\u0026#34;adad\u0026#34;;println!(\u0026#34;{}\u0026#34;,str1);}  上例中的 str2 和 str3 从未使用过，所以只会报 warning。\n早期 Rust 对借用的检查比较死板，引入 NLL （Non Lexical Lifetime）以后可以更精细的调节变量的作用范围，对于一些不会产生安全问题的写法放宽了限制：\n1 2 3 4 5 6 7 8 9 10 11 12  fn main(){letmutdata=vec![\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;];letslice=\u0026amp;mutdata[..];foreleminslice{elem.make_ascii_uppercase();}data.push(\u0026#39;c\u0026#39;);println!(\u0026#34;{:?}\u0026#34;,data);}  1 2 3 4 5 6 7 8 9 10  fn process_or_default(){letmutmap=...;letkey=...;matchmap.get_mut(\u0026amp;key){Some(value)=\u0026gt;process(value),None=\u0026gt;{map.insert(key,V::default());}}}  ","description":"","id":13,"section":"posts","tags":["Rust","Rust Edition Guide","Programing"],"title":"[Rust 基础知识]借用与借用规则","uri":"https://saberuster.github.io/posts/rust-basic-03/"},{"content":"前言  迭代器是 Rust 中的重要功能之一，在 Rust 中迭代器指的是实现了 Iterator trait 的类型。本文以最短篇幅囊括迭代器的相关知识点。\n实现 Interator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  externcratehello_rust;struct Counter{num: i32,}implIteratorforCounter{type Item=i32;fn next(\u0026amp;mutself)-\u0026gt; Option\u0026lt;Self::Item\u0026gt;{ifself.num\u0026lt;6{self.num+=1;Some(self.num)}else{None}}}fn main(){letc=Counter{num: 0};forninc{println!(\u0026#34;{}\u0026#34;,n);}println!(\u0026#34;end!\u0026#34;);}  迭代器的组合  Rust 迭代器的一个重要特性就是可以组合的：\n1 2 3 4 5 6 7 8 9 10 11  fn main(){letv=vec![1,2,3,4,5,6,7,8,9];v.iter().take(5).filter(|\u0026amp;x|x%2==0).map(|\u0026amp;x|x*x).for_each(|x|println!(\u0026#34;{}\u0026#34;,x));println!(\u0026#34;end!\u0026#34;);}  如此写法除了可读性较高以外还有对并行计算友好的优点（详细的可参考 Rust 各种并行库）。\n惰性求值  Rust 迭代器的另一个特性就是惰性求值：\n1 2  letv=vec![1,2,3,4,5];v.iter().map(|x|println!(\u0026#34;{}\u0026#34;,x));  上面的代码并不会打印任何东西，因为想要迭代器运行需要消费数据的操作，例如 v.iter().map(...).for_each(|x| println!(\u0026quot;{}\u0026quot;, x));\n","description":"","id":14,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] Iterator 初见","uri":"https://saberuster.github.io/posts/rust-trait-09/"},{"content":"前言  本文以最短篇幅概述 Rust 所有权和移动语义的基础知识点。之后几篇都会是所有权和生命周期的文章，这里先把基础的点整理一下。\n想解决的问题  思考以下场景：\n1 2  Foo *p = new_object(\u0026#34;args\u0026#34;); // create ptr use_object(p); // use ptr   在不点进 use_object 前提下我们其实无从知道它对指针 p 到底做了什么，这就带来了很大的安全风险。为了缓解这种现象，一种目前应用广泛的方式就是使用“智能指针”。而 Rust 更进一步，将所有权的理念融入语言之中。\n一般在讨论 Rust 的所有权时需要知道：\n Rust 中每个值都有一个变量作为所有者 每个值在同一时间只能有一个管理者 当变量离开作用域时它的值也会被销毁  一个最简单的例子：\n1 2 3 4 5 6 7 8  fn main(){lets=String::from(\u0026#34;asd\u0026#34;);lets2=s;println!(\u0026#34;{}\u0026#34;,s2);//println!(\u0026#34;{}\u0026#34;, s); error!! }  在 s 将所有权转移到 s2 以后我们再使用 s 就是非法的。如果想要 s 和 s2 都有效一种方式是显式进行克隆操作：\n1 2 3 4 5 6 7 8  fn main(){lets=String::from(\u0026#34;asd\u0026#34;);lets2=s.clone();println!(\u0026#34;{}\u0026#34;,s2);println!(\u0026#34;{}\u0026#34;,s);}  移动语义  在 Rust 中赋值语句，函数调用，函数返回都可能发生所有权转移。而所有权转移也是所有类型的默认语义（之前的文章提过可以通过 Copy trait 改变）。\n1 2 3 4 5 6 7 8 9 10 11 12 13  fn create()-\u0026gt; String {lets=String::from(\u0026#34;asd\u0026#34;);s}fn consume(s: String){println!(\u0026#34;{}\u0026#34;,s);}fn main(){lets2=create();consume(s2);}  上例中 String 的所有权从 create 内部转移到 main 然后又移入 consume 内部。这个所有权转移的过程我们可以简单的理解成 memcpy。不过需要注意的是理解成 memcpy 并不代表它真的是按 memcpy 执行的，编译器会在不改变代码语义的前提下帮我们做优化，所以不用纠结这个点。\nBox  Box 是 Rust 中的一种常用指针类型，表示“具有所有权的指针”：\n1 2 3 4 5 6 7 8  struct T{index: i32,}fn main(){lettp=Box::new(T{index: 1});println!(\u0026#34;{}\u0026#34;,tp.index);}  在 Rust 中，所有的变量在使用前必须要合理初始化，这也意味着 Box\u0026lt;T\u0026gt; 一定是指向某个具体对象的。如果我们想要一个可能为空的指针，可以套个Option Option\u0026lt;Box\u0026lt;T\u0026gt;\u0026gt;;\n总结  作为 Rust 中最为重要的内容之一，这块的内容肯定很多，由于水平和时间限制只能挑一些我还能理解的写出来，等积累到一定程度再写一些更有深度的东西。\n","description":"","id":15,"section":"posts","tags":["Rust","Rust Edition Guide","Programing"],"title":"[Rust 基础知识]所有权与移动语义","uri":"https://saberuster.github.io/posts/rust-basic-02/"},{"content":"前言  本篇文章以最短的文字囊括 Rust 可变性的主要知识点。\n声明可变变量 1  letmutx=5;  我们在理解它的时候需要把 mut x 理解为一个整体，所以我们在模式解构元组的时候会这么写：\n1  let(muta,mutb)=(1,2);  在函数绑定中它的行为和 C++ 的 const 函数的规则类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  struct Test{}implTest{fn test_fn1(\u0026amp;self)-\u0026gt; i32 {1}fn test_fn2(\u0026amp;mutself)-\u0026gt; i32 {2}}fn main(){lett=Test{};letmutt2=Test{};t.test_fn1();t2.test_fn1();t2.test_fn2();}  不可变变量 t 只能调用 \u0026amp;self 函数，而可变的 t2 可以调用 \u0026amp;self 和 \u0026amp;mut self 的函数。\n不过这种程度显然不能满足开发者的需求，假如 Rust 的引用计数智能指针 Rc：\n1 2 3 4 5 6 7 8 9 10  externcratehello_rust;usestd::rc::Rc;fn main(){letrc1=Rc::new(1);println!(\u0026#34;rc count: {}\u0026#34;,Rc::strong_count(\u0026amp;rc1));letrc2=rc1.clone();println!(\u0026#34;rc count: {}\u0026#34;,Rc::strong_count(\u0026amp;rc2));}  没有 mut 好像它的内部数据依然是可以改变的。这就涉及到 Rust 中内部可变性（interior mutability）的概念。\n（这里排除自己手写 unsafe 代码）\n内部可变性  前面提到有些时候业务上就是需要像 Rc 一样具有内部可变性的类型，Rust 的解决方案是提供 std::cell::UnsafeCell 类型：\n1 2 3 4 5 6 7  #[lang = \u0026#34;unsafe_cell\u0026#34;]#[repr(transparent)]#[repr(no_niche)]pubstruct UnsafeCell\u0026lt;T\u0026gt;whereT: ?Sized,{/* fields omitted */}  看到 #[lang = \u0026ldquo;xxx\u0026rdquo;] 我们就知道它会被编译器特别关照。该类型的 get 方法可以从 \u0026amp;self 中拿到 *mut T 指针，这也是我们实现内部可变性的重要途径。\n1 2 3 4 5 6 7 8 9  #[inline]#[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]#[rustc_const_stable(feature = \u0026#34;const_unsafecell_get\u0026#34;, since = \u0026#34;1.32.0\u0026#34;)]pubconstfn get(\u0026amp;self)-\u0026gt; *mutT{// We can just cast the pointer from `UnsafeCell\u0026lt;T\u0026gt;` to `T` because of // #[repr(transparent)]. This exploits libstd\u0026#39;s special status, there is // no guarantee for user code that this will work in future versions of the compiler! selfas*constUnsafeCell\u0026lt;T\u0026gt;as*constTas*mutT  排除多线程情况下的安全问题主要靠 !Sync：\n1 2  #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]impl\u0026lt;T: ?Sized\u0026gt;!SyncforUnsafeCell\u0026lt;T\u0026gt;{}  这样所有需要 Sync 约束类型的地方 UnsafeCell 全都无法直接使用。\n我们在实际使用的时候可以直接用 Cell 或者 RefCell:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  externcratehello_rust;usestd::cell::Cell;fn main(){letdata=Cell::new(1);letp=\u0026amp;data;data.set(2);println!(\u0026#34;{}\u0026#34;,p.get());p.set(3);println!(\u0026#34;{}\u0026#34;,data.get());}  这里面在程序上的逻辑在于对于需要内部可变的类型 T，我们把它用 Cell 包裹，在平时我们的所有引用都在 Cell 上，这样对于 Cell 的外部来说没有任何逻辑冲突。而因为在 Cell 内部我们利用了 Rust 提供的 UnsafeCell 得以实现对内部数据的修改。\n","description":"","id":16,"section":"posts","tags":["Rust","Rust Std","Programing"],"title":"[Rust 基础知识]mut 与可变性","uri":"https://saberuster.github.io/posts/rust-basic-01/"},{"content":"前言  在 Rust 的 std::maker 中有几个特殊的 trait，我们之前聊到的 Copy 就是其中一个，他们都是用来描述类型的内在属性，更多的是给编译器需要的额外信息。本篇作为初见会先从整体上概括知识点。\nSend/Sync  这两个 trait 主要针对并发编程的数据竞争的问题。在正常开发过程中我们时常会遇到一个问题就是区分哪些类型是具有并发安全的属性。例如实现了 Send trait 的类型表示它在不同线程之间进行 move 是安全的。而实现了 Sync trait 的类型表示在多个线程中使用 \u0026amp;T 是安全的。而这两个 trait 本身是由编译器自动推导的，所以我们更多看到它们是在泛型的类型约束上。真的要把一些线程不安全的类型转换成线程安全的还是得靠例如 Mutex 这些东西。\nSized  凡是能在编译阶段就能确定大小的类型都是满足 Sized 约束的。说句人话就是其实我们开发中经常遇到的大部分都满足 Sized。有一些特殊的动态大小类型不满足 Sized，例如不定长数组。因为函数的返回值必须是确定大小的类型，动态大小类型无法直接返回，必须隐藏在指针后面，所以在直觉上很少遇到这种动态类型。\nUnpin  Rust 中默认是移动语义，但是有时我们就是不希望这种移动发生。这就需要利用到 Pin 类型。而 Unpin 约束让类型不用受到这种限制。（老实说以前没做过类似的东西，所以目前还不太理解当中存在的必要性，等以后专门做一篇关于 Pin 的文章再讲）。\nauto trait  std::marker 中的 trait 都和 Rust 语言本身有着紧密关系。虽然它们任意一个概念单独拉出来都有很多其他东西，不过他们有一个共通点：那就是他们都是编译器一次帮我们在所有能够满足的类型上面实现，个人感觉有点 Golang 自动实现 interface 的那种意思。这个能力也是 Rust 提供我们的一个 feature，作为普通用户也能使用这个能力（虽然还没 stable）。这个在 Rust 中之前叫 OIBIT，现在叫 auto trait：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #![feature(negative_impls)]#![feature(auto_traits)]autotraitValid{}struct True;struct False;impl!ValidforFalse{}struct MaybeValid\u0026lt;T\u0026gt;(T);fn must_be_valid\u0026lt;T: Valid\u0026gt;(_t: T){}fn main(){// works must_be_valid(MaybeValid(True));// compiler error - trait bound not satisfied // must_be_valid( MaybeValid(False) ); }  比较有意思的是它能够通过感叹号来指定某些类型不要实现一些 trait：\n1  impl!TraitforType  ","description":"","id":17,"section":"posts","tags":null,"title":"[Rust Std Trait] std::marker 与 auto trait 初见","uri":"https://saberuster.github.io/posts/rust-trait-08/"},{"content":"前言  书接上文，这次我们来聊聊剩下的几种类型转换 trait。\nBorrow/BorrowMut  前文的 AsRef\u0026lt;T\u0026gt; 更像是简单的 T getter 逻辑。而 Borrow\u0026lt;T\u0026gt; 个人理解更多表述的是针对 T 类型的拓展，本质上是针对相同意思的不同表述。说句人话，就是类似 String 和 str 的关系，虽然类型不同功能不同，但是他们在类型含义上都是表示“字符串”的意思，所以 String 表示的 “a” 和 str 表示的 “a” 应该是相等的。所以约定对于 Eq，Ord，Hash trait 有 if x == y =\u0026gt; x.borrow() == y.borrow()。以 HashMap 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  usestd::borrow::Borrow;usestd:#️⃣:Hash;pubstruct HashMap\u0026lt;K,V\u0026gt;{// fields omitted }impl\u0026lt;K,V\u0026gt;HashMap\u0026lt;K,V\u0026gt;{pubfn insert(\u0026amp;self,key: K,value: V)-\u0026gt; Option\u0026lt;V\u0026gt;whereK: Hash+Eq{// ... }pubfn get\u0026lt;Q\u0026gt;(\u0026amp;self,k: \u0026amp;Q)-\u0026gt; Option\u0026lt;\u0026amp;V\u0026gt;whereK: Borrow\u0026lt;Q\u0026gt;,Q: Hash+Eq+?Sized{// ... }}  ToOwned  ToOwned 是 Borrow 的反向版本，功能类似 Clone， Clone 是从 \u0026amp;T 到 T，而 ToOwned 是从 \u0026amp;T 到 Borrow\u0026lt;T\u0026gt;。\n1 2 3 4 5  lets: \u0026amp;str =\u0026#34;a\u0026#34;;letss: String =s.to_owned();letv: \u0026amp;[i32]=\u0026amp;[1,2];letvv: Vec\u0026lt;i32\u0026gt;=v.to_owned();  ToString/FromStr  我们可以给类型实现 Display trait，因为 Rust 已经预定义了一个基于 Display 的实现：\n1 2 3 4 5 6 7 8 9 10  impl\u0026lt;T: fmt::Display+?Sized\u0026gt;ToStringforT{#[inline]default fnto_string(\u0026amp;self)-\u0026gt; String {usefmt::Write;letmutbuf=String::new();buf.write_fmt(format_args!(\u0026#34;{}\u0026#34;,self)).expect(\u0026#34;a Display implementation returned an error unexpectedly\u0026#34;);buf}}  我在看基于旧版本的 Rust 的书中写的 Display 是可以自动 derive 的，而我在查阅当前版本的标准库文档中已经明确说明不能 derive：\n Display is similar to Debug, but Display is for user-facing output, and so cannot be derived.\n  FromStr 提供从 \u0026amp;str 到 T 的转换：\n1 2 3 4 5  pubtraitFromStr{type Err;pubfn from_str(s: \u0026amp;str)-\u0026gt; Result\u0026lt;Self,Self::Err\u0026gt;;}  由于可能出现失败的情况所以返回的是 Result\u0026lt;Self, Self::Err\u0026gt;。\n","description":"","id":18,"section":"posts","tags":null,"title":"[Rust Std Trait] 类型转换 trait 初见（二）","uri":"https://saberuster.github.io/posts/rust-trait-07/"},{"content":"前言  虽然在 Rust 中提供了用于做基本类型转换的关键字 as，但是自定义类型也有类型转换的需求，所以 Rust 标准库为我们提供了一系列 trait 来解决这个问题。本篇文章以最短的篇幅概括 类型转换相关 trait 的主要知识点。\nAsRef/AsMut  这两个 trait 主要负责从 A 类型的 \u0026amp;self/\u0026amp;mut self 转换成 B 类型的 \u0026amp;/\u0026amp;mut：\n1 2 3 4 5 6 7 8 9 10 11 12 13  pubtraitAsRef\u0026lt;T\u0026gt;whereT: ?Sized,{pubfn as_ref(\u0026amp;self)-\u0026gt; \u0026amp;T;}pubtraitAsMut\u0026lt;T\u0026gt;whereT: ?Sized,{pubfn as_mut(\u0026amp;mutself)-\u0026gt; \u0026amp;mutT;}  需要注意的点：\n 这两个都是用来做那种比较简单的转换，类似直接返回的那种。如果在类型转换消耗很大应该考虑使用 From 或者自定义函数 这两个 trait 做的类型转换都不能失败。如果类型转换存在失败的可能需要自己写自定义函数 AsRef 和 Borrow 的区别还没真正理解，先挖个坑，等研究 HashMap 的时候再填  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  externcratehello_rust;struct Name(\u0026amp;\u0026#39;staticstr);fn show_name\u0026lt;T: AsRef\u0026lt;Name\u0026gt;\u0026gt;(item: T){println!(\u0026#34;name is :{}\u0026#34;,item.as_ref().0);}struct Bus{vehicle_name: Name,}implAsRef\u0026lt;Name\u0026gt;forBus{fn as_ref(\u0026amp;self)-\u0026gt; \u0026amp;Name{\u0026amp;self.vehicle_name}}struct Apple{fruit_name: Name,}implAsRef\u0026lt;Name\u0026gt;forApple{fn as_ref(\u0026amp;self)-\u0026gt; \u0026amp;Name{\u0026amp;self.fruit_name}}fn main(){letbus=Bus{vehicle_name: Name(\u0026#34;bus\u0026#34;),};letapple=Apple{fruit_name: Name(\u0026#34;apple\u0026#34;),};show_name(bus);show_name(apple);}  From/Into  这两个 trait 主要处理 A 和 B 值类型之间的相互转换。标准库中还存在他俩的可失败版本 TryFrom/TryInto。\n1 2 3 4 5 6 7 8  pubtraitFrom\u0026lt;T\u0026gt;{#[lang = \u0026#34;from\u0026#34;]pubfn from(T)-\u0026gt; Self;}pubtraitInto\u0026lt;T\u0026gt;{pubfn into(self)-\u0026gt; T;}  需要注意的点：\n 因为实现 From 时标准库会有一个 Into 的预制实现。然而反过来并不是，所以我们应该优先选择实现 From trait 声明时优先使用 Into，因为 From 会自动实现 Into 而 Into 并不会自动实现 From From/Into 都不允许失败，如果有可能失败可以选择 TryFrom/TryInto From 在 Rust 的错误处理中应用广泛  ","description":"","id":19,"section":"posts","tags":null,"title":"[Rust Std Trait] 类型转换 trait 初见（一）","uri":"https://saberuster.github.io/posts/rust-trait-06/"},{"content":"前言  由于 ops 中的很多 trait 功能类似，所以就不一个一个来了。本篇文章以最短的篇幅概括 std::ops 中还未提及的主要知识点。\n运算符重载  最基础的就是对四则运算之类的操作符进行重载了。这里借用计算点坐标的例子来演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  externcratehello_rust;usestd::ops::Add;#[derive(Debug, Clone, Copy)]struct Point{x: i32,y: i32,}implAddforPoint{type Output=Self;fn add(self,rhs: Point)-\u0026gt; Self{Self{x: self.x+rhs.x,y: self.y+rhs.y,}}}fn main(){println!(\u0026#34;{:?}\u0026#34;,Point{x: 1,y: 2}+Point{x: 2,y: 1});}  FnOnce/FnMut/Fn  Rust 中用 fn 可以定义函数，而 Fn 可以对函数做抽象。三种不同形态对应 self 参数的传递类型。FnOnce 对应 move 传递，这样的函数不能执行多次，所以签名带了个 Once。FnMut/Fn 分别对应 \u0026amp;mut Self 和 \u0026amp;Self 类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  pubtraitFnOnce\u0026lt;Args\u0026gt;{type Output;pubextern\u0026#34;rust-call\u0026#34;fn call_once(self,args: Args)-\u0026gt; Self::Output;}pubtraitFnMut\u0026lt;Args\u0026gt;: FnOnce\u0026lt;Args\u0026gt;{pubextern\u0026#34;rust-call\u0026#34;fn call_mut(\u0026amp;mutself,args: Args)-\u0026gt; Self::Output;}pubtraitFn\u0026lt;Args\u0026gt;: FnMut\u0026lt;Args\u0026gt;{pubextern\u0026#34;rust-call\u0026#34;fn call(\u0026amp;self,args: Args)-\u0026gt; Self::Output;}letx=String::from(\u0026#34;x\u0026#34;);letconsume_and_return_x=move||x;// FnOnce() -\u0026gt; String letmutsquare_x=||x*=x;// FnMut() letdouble=|x|x*2;// Fn()   编译器在自动为闭包实现 trait 的时候会先试 Fn 不行再 FnMut 最后 FnOnce。\n文档中特别提到如果 F 实现了 Fn 那么自动 \u0026amp;F 也实现了 Fn。这句话我们可以利用下面的例子来感受一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  externcratehello_rust;fn test_fn\u0026lt;T\u0026gt;(f: \u0026amp;T)whereT: Fn(),{f();}fn main(){leta=||println!(\u0026#34;hello world\u0026#34;);test_fn(\u0026amp;a);}  Range 语法  Range 语法总共六种形态：\n1 2 3 4 5 6 7 8 9 10 11 12  externcratehello_rust;fn main(){letarr=[0,1,2,3];assert_eq!([0,1,2,3],arr[..]);assert_eq!([1,2,3],arr[1..]);assert_eq!([0,1],arr[..2]);assert_eq!([0,1,2],arr[..=2]);assert_eq!([1],arr[1..2]);assert_eq!([1,2],arr[1..=2]);}  ","description":"","id":20,"section":"posts","tags":null,"title":"[Rust Std Trait] std::ops 初见","uri":"https://saberuster.github.io/posts/rust-trait-05/"},{"content":"前言  在平时的开发中，我们可能需要利用析构函数来做一些收尾工作。在 Rust 中我们可以利用 Drop trait 来实现。本篇文章将会用最短的篇幅覆盖 Drop 的主要知识点。\nimpl Drop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  externcratehello_rust;struct DT{id: i32,}implDropforDT{fn drop(\u0026amp;mutself){println!(\u0026#34;drop call!\u0026#34;);}}fn main(){letdt=DT{id: 1};println!(\u0026#34;{:?}\u0026#34;,dt.id);}  主动析构  一般我们定义的局部变量生命周期都是当前语句块， 析构顺序“先进后出”。不过 Rust 中我们也可以手动使用 drop 函数提前结束它的生命周期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  externcratehello_rust;struct DT{id: i32,}implDropforDT{fn drop(\u0026amp;mutself){println!(\u0026#34;drop call!\u0026#34;);}}fn main(){letdt=DT{id: 1};drop(dt);// 这里不能直接调用 dt.drop() println!(\u0026#34;end!\u0026#34;);}  drop 函数体内啥也没有，单纯就是把所有权拿到然后函数结束才好让析构函数执行。也因为它利用了 Rust 默认的移动语义，它和 Copy trait 是有冲突的。所以在 Rust 中同一个类型是不允许同时实现 Copy 和 Drop 的。\n析构函数的调用是在编译阶段就确定好的，而我们可以在代码的不同执行路径中主动析构从而影响析构函数的调用顺序，那这不是矛盾吗？\n1 2 3 4 5  matchcondition{Some(1)=\u0026gt;drop(var1)Some(2)=\u0026gt;drop(var2)_=\u0026gt;{}}  其实这里我们可以理解为 Rust 会用一个布尔值来判断，如果执行到最后还没有析构过才会调用析构函数。如果在执行期间已经析构了，是不会重复调用的。\n","description":"","id":21,"section":"posts","tags":null,"title":"[Rust Std Trait] Drop 初见","uri":"https://saberuster.github.io/posts/rust-trait-04/"},{"content":"前言  Copy 作为能够影响编译器行为的 trait 对我们理解 Rust 基础有着重要作用，而 Clone 是我们作为搬砖工人能够自定义复制行为的 trait。本篇文章将会用最短的篇幅覆盖 Copy 和 Clone 的主要知识点。\n至关重要的 Copy trait  提问，以下代码为何 print1 行不报错：\n1 2 3 4 5 6 7 8  externcratehello_rust;fn main(){letnum1=1i32;letnum2=num1;println!(\u0026#34;{}\u0026#34;,num1);// print 1 println!(\u0026#34;{}\u0026#34;,num2);// print 2 }  其实这里就需要理解 Copy trait 在当中起的作用。如果一个类型实现了 Copy trait，那么它在变量绑定，函数参数传递，函数返回值的场景等场景下都是 copy 语义，而不是默认的 move 语义。上面的例子因为 Rust 已经帮你把 i32 的 Copy trait 实现好了，所以才以 Copy 语义使用。所以，即使是我们自己定义的类型，只要实现了 Copy trait 也会变成 Copy 语义：\n1 2 3 4 5 6 7 8 9 10 11  externcratehello_rust;#[derive(Debug, Copy, Clone)]struct TA(i32);fn main(){lett1=TA(1);lett2=t1;println!(\u0026#34;{:?}\u0026#34;,t1);// print 3 println!(\u0026#34;{:?}\u0026#34;,t2);// print 4 }   Copy trait 对类型有一定要求，如果想让我们的自定义类型实现 Copy trait，那么它的所有成员都必须是实现了 Copy trait 的。标准库除常规 impl 的类型外还特别提及以下类型也是 Copy 的：\n 函数/函数指针 元素为 Copy 的数组和元组 闭包（不捕获或者捕获 Copy）  能够自定义的 Clone trait  Copy 的行为我们是无法控制的。如果我们想自定义例如“类型深复制”的行为，可以实现 Clone trait。Copy 是隐式改变编译器的行为，而 Clone 需要我们显式调用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  externcratehello_rust;#[derive(Debug, Clone)]struct CT{field1: i32,field2: bool,}fn main(){letct=CT{field1: 1,field2: false,};println!(\u0026#34;{:?}\u0026#34;,ct.clone());}  如果我们想自定义 Clone trait 的行为可以手动实现 trait，Rust 不会限制你的具体自定义实现，不过对于同时还要实现 Copy trait 的类型都确保 Clone 和 Copy 代表的语义相同。可以直接在 derive 中二连使用。\n1 2 3 4 5 6 7 8 9 10 11  implCloneforCT{fn clone(\u0026amp;self)-\u0026gt; Self{*self}}// or #[derive(Debug, Copy, Clone)]struct CT{field1: i32,field2: bool,}  ","description":"","id":22,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] Copy/Clone 初见","uri":"https://saberuster.github.io/posts/rust-trait-03/"},{"content":"前言  由于需要考虑全序关系（例如 Rust 浮点数中的 NaN），Rust 中有两套 trait 分别定义满足“全序”关系的 Ord/Eq 只能构成“偏序”关系的 PartialOrd/PartialEq。本文致力于用最短的篇幅覆盖标准库中Ord,Eq,PartialOrd,PartialEq的主要知识点。\nEq/PartialEq  Eq 和 PartialEq 在概念上的区别主要是否满足 a == a，乍看之下是句废话。实则不然，例如 a = NaN 就是特例。而在 trait 的定义上 Eq 是基于 PartialEq 的，Eq 自己更多是起修饰作用，在#[derive]中，PartialEq 在类型字段全部相等时为 true反之false，而 Eq 只是约束类型全字段也满足 Eq。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  externcratehello_rust;#[derive(Debug, Eq)]struct MyItem{id: i32,//... other Eq fields }implPartialEqforMyItem{fn eq(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; bool {self.id==other.id}}fn main(){letitem1=MyItem{id: 1};letitem2=MyItem{id: 1};assert_eq!(item1,item2);}   不难看出如果我们想用这套 trait，PartialEq 需要无脑怼上。需不需要 Eq 可以再考虑。\nOrd/PartialOrd  和前文一样，做这种区分就是因为一些特殊值例如 NaN \u0026lt; 0 == false 并且 NaN \u0026gt;= 0 == false。而在 trait 定义上 PartialOrd 基于 PartialEq 而 Ord 是 Eq + PartialOrd。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  usestd::cmp::Ordering;#[derive(Eq)]struct Person{id: u32,name: String,height: u32,}implPartialOrdforPerson{fn partial_cmp(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; Option\u0026lt;Ordering\u0026gt;{Some(self.cmp(other))}}implOrdforPerson{fn cmp(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; Ordering{self.height.cmp(\u0026amp;other.height)}}implPartialEqforPerson{fn eq(\u0026amp;self,other: \u0026amp;Self)-\u0026gt; bool {self.height==other.height}}  总结  虽然上例演示使用了这套 trait，不过还是要说除 == 和 != 以外的其他运算符的语义都比较固定，适用范围有限，避免滥用。\n","description":"","id":23,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] (Partial)Ord/Eq 初见","uri":"https://saberuster.github.io/posts/rust-trait-02/"},{"content":"前言  本文致力于用最短的篇幅覆盖标准库中Default trait的主要知识点。\n功能介绍  Default trait 可以用于定义类型的默认值。基础用法举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #[derive(Debug)]struct TraitTest{enable: bool,type_id: i32,}implDefaultforTraitTest{fn default()-\u0026gt; Self{TraitTest{enable: true,type_id: 1,}}}fn main(){lettd=TraitTest::default();println!(\u0026#34;{:?}\u0026#34;,td);}  如果我们就是想用字段类型本身的默认值，不想像上面的例子一样指定特定值的话，用上面的写法明显会有大段的冗余代码。\n标准库已经为我们想到了：\n1 2 3 4 5 6 7 8 9 10  #[derive(Default, Debug)]struct TraitTest2{a: i32,b: bool,}fn main(){lettd2=TraitTest2::default();println!(\u0026#34;{:?}\u0026#34;,td2);}  这里需要注意的是在使用 #[derive] 的时候要确保类型的所有字段也都实现了 Default trait。\n一些基础类型在定义 Default trait 源码已经给他做实现了，所以我们可以直接用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /// default.rs 源码 macro_rules!default_impl{($t:ty,$v:expr,$doc:tt)=\u0026gt;{#[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)]implDefaultfor$t{#[inline]#[doc = $doc]fn default()-\u0026gt; $t{$v}}}}default_impl!{(),(),\u0026#34;Returns the default value of `()`\u0026#34;}default_impl!{bool,false,\u0026#34;Returns the default value of `false`\u0026#34;}default_impl!{char,\u0026#39;\\x00\u0026#39;,\u0026#34;Returns the default value of `\\\\x00`\u0026#34;}default_impl!{usize,0,\u0026#34;Returns the default value of `0`\u0026#34;}/// ... 其他定义就省略了   在实践中我们经常会遇到一种情况：只想指定类型其中一个或几个字段的值。这种需求也有比较完美的解决方案：\n1 2 3 4 5 6 7 8  fn main(){lettd3=TraitTest{enable: false,..TraitTest::default()};println!(\u0026#34;{:?}\u0026#34;,td3);}  你可能觉得像上面一样在 TraitTest 里面用 TraitTest::default() 有点冗余。这个标准库也已经想到了(虽然目前还没stable)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #![feature(default_free_fn)]usestd::default::default;/// ... def code fn main(){lettd3=TraitTest{enable: false,..default()};println!(\u0026#34;{:?}\u0026#34;,td3);}  总结  虽然Rust比较复杂，但是真的用起来会发现不管是工具链还是代码书写总体来说是舒服的。尤其2019和2020年都已肉眼可见的速度变好。接下来我也会定期更一些Rust相关的基础文章为将来撸代码做准备。\n","description":"","id":24,"section":"posts","tags":["Rust","Rust Std","Programing","Rust trait"],"title":"[Rust Std Trait] Default 初见","uri":"https://saberuster.github.io/posts/rust-trait-01/"},{"content":"问题描述  在ue4开发中本人之前一直有一种接口定义的困境，定义支持蓝图的接口吧在代码里用着不舒服，有点影响开发效率。定义只支持C++的接口吧蓝图还要用。\n后来翻 GameplayAbility 插件的源码的时候发现人家的解决方案挺简单有效的，特此拿来借鉴一下。\n问题的解决方式 在 GameplayAbility 插件中定义了一个 IAbilitySystemInterface 接口，该接口只有一个普通的 C++ 纯虚函数。这种定义也是我们在代码里用着比较舒服的。缺点就是本身在蓝图中用不了。\n1 2 3 4 5 6 7  class GAMEPLAYABILITIES_API IAbilitySystemInterface { GENERATED_IINTERFACE_BODY() /** Returns the ability system component to use for this actor. It may live on another actor, such as a Pawn using the PlayerState\u0026#39;s component */ virtual UAbilitySystemComponent* GetAbilitySystemComponent() const = 0; };   为了支持蓝图，它的做法是在蓝图函数库中定义一个相同功能的静态函数：\n1 2  UFUNCTION(BlueprintPure, Category = Ability) static UAbilitySystemComponent* GetAbilitySystemComponent(AActor *Actor);   从蓝图侧传入Actor然后在代码里面判断Actor是否实现了接口，如果实现了直接调用接口，没有的话还可以通过遍历组件找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  if (Actor == nullptr) { return nullptr; } const IAbilitySystemInterface* ASI = Cast\u0026lt;IAbilitySystemInterface\u0026gt;(Actor); if (ASI) { return ASI-\u0026gt;GetAbilitySystemComponent(); } if (LookForComponent) { /** This is slow and not desirable */ ABILITY_LOG(Warning, TEXT(\u0026#34;GetAbilitySystemComponentFromActor called on %s that is not IAbilitySystemInterface. This slow!\u0026#34;), *Actor-\u0026gt;GetName()); return Actor-\u0026gt;FindComponentByClass\u0026lt;UAbilitySystemComponent\u0026gt;(); } return nullptr;   个人感觉这种方式比直接在接口文件中直接定义蓝图可用的接口灵活很多。\n","description":"","id":25,"section":"posts","tags":["折腾日记","UE4","动画","C++"],"title":"UE4 中一种 Blueprint\u0026C++ 统一化接口的小技巧","uri":"https://saberuster.github.io/posts/ue4-02/"},{"content":"前言  作为虚幻4的白嫖党，Mixamo 一定是不能错过的。本篇文章总结了 Mixamo 中动画迁移到虚幻4项目中的知识点。\n导入基础骨架  Mixamo 中动画的骨架和虚幻4小白人是不一样的，如果我们直接把动画导入进引擎我们小白人也用不了。解决方案就是把 Mixamo 中那套通用的骨架先导入进引擎，然后再在引擎中把动画 retarget 到小白人的骨架上。\n 因为我们要导入的骨架其实就是做个中间层，不需要乱七八糟的贴图材质啥的，所以我就选择了 Mixamo 中的 YBot 角色，因为它比较干净。这里要注意导出的时候要选 T Pose。\n然后将其导入引擎。之后我们从 Mixamo 中导出的所有动画在导入引擎的时候都选择这个骨架就可以了。\n类人绑定  为了能够把动画转到小白人上我们需要将骨架进行类人绑定。这是虚幻4中的一个现成的功能，只需要自己配置一下。\n小白人自己的骨架知道让系统自动绑定就行了。主要就是上面提到的 Mixamo 的基础骨架。因为它和小白人骨架的差别较大需要自己耐心一个一个调一调。\n 完成之后需要在骨骼的那个树状图的 Option 中开启 retarget options 显示。然后把除了 Hips 以外的所有骨骼设置成skeleton（默认是 Animation）。\n把小白人设置成 T Pose  小白人默认是 A Pose。为了能够迁移我们需要手动把他调成 T Pose 的。直接再骨骼界面旋转调整，满意后点击 retarget manager 页面的 ModifyPose，选择 Current Pose 即可。\n开始迁移动画  完成上面的操作我们就可以快乐的把 Mixamo 中的动画给小白人用啦！想迁移单个动画就在动画序列上右键然后 retarget。要是想一次迁移全部就直接在骨骼上右键retarget就可以了。\n参考索引(需要翻墙) ","description":"","id":26,"section":"posts","tags":["折腾日记","UE4","动画"],"title":"在虚幻4中使用 Mixamo 的动画","uri":"https://saberuster.github.io/posts/ue4-01/"},{"content":" 在使用 Houdini 构建自己的 HDA 工具的时候经常会需要通过 Input 传入基础几何体信息。而我们又希望在无输入的情况下能有个默认值效果。经过几个 HDA 工具的开发，自己简单总结成了以下两步：\n利用 switchif 做默认值切换  这里选择 switchif 而不是 switch 是因为 switchif 是在 0 和 1 之间切换，而 switch 可以不止两个输入。在节点的表述性上更加直观。其次 switchif 内置选项中集成了 npoints 功能（虽然手写个表达式就多敲7个字母的问题而已，不过等节点多起来脑子要判断这个框里写的啥还是要想一下）。\n switchif 需要注意两点：节点选择 0 还是 1 分别对应断言的 false 和 true，与断言语义无关。还可以利用 spare input 将非输入节点引入断言。\n利用 disable when 禁用默认配置  在连接了 Input 以后我们希望能够把默认配置的选项都禁用掉，这时就需要用到 disable when 的语法:\n这里的语法在官方文档有比较全面的参考\n示例 HDA 下载地址\n ","description":"","id":27,"section":"posts","tags":["折腾日记","Houdini","3D美术","Houdini Tips"],"title":"【Houdini Tips】给输入设置默认几何体","uri":"https://saberuster.github.io/posts/houdini-tips-01/"},{"content":"前言  本来近期想在blender里面做一小套场景拿到UE4里面测试一下光照和后期的。陆陆续续做了些场景内容后发现一个很让我头疼的问题：每次我想在Mesh上改点什么都需要把之后展UV，LowPoly，HighPoly，各种贴图烘焙等整个流程全部都走一遍。作为一名非专业3D美术技术人员，我并没有找到什么好的办法来解决这个问题。然而对于我来讲每天的工作内容很多，不可能在这上面浪费太多时间，所以我重拾起了电脑里面快半年没打开的houdini打算利用它来搞定这个需求。经过两天的研究初步总结出了一套适用于我个人的3D美术资产的pipline:\nblender打Mesh草稿-\u0026gt;去houdini里面创建HDA进行程序生成和参数化-\u0026gt;利用Gamedev插件做贴图烘焙和fbx导出或者直接利用houdini engine直接把HDA怼到引擎里面\n PS:其实Blender利用UE4官方的SendToUnreal插件也能直接把Mesh怼到引擎里面预览，减轻了Mesh导入导出的成本，不过在blender端修改Mesh的工作量还是没有减少。所以我目前觉得SendToUnreal更多的是作为引擎多边形编辑工具的拓展，重点在我上面的打Mesh草稿阶段，对整个美术资产制作流程的优化作用有限。\n关于 procedural modeling 的思考  不断完善自己工具链的过程也是明确自身需求的过程。就我个人而言因为美术功底和艺术上的创造力近乎于无，最多就是去artstation上找找灵感，然后到处翻教程。所以本身无法在这个方向获得足够的竞争力。而相比之下鄙人在编程上面相对擅长一些，所以我是更能够接受把程序化建模引入工作流并不断优化，同时放弃一些美术上自由度的方案。\nDemo示例 下面通过一个蒸笼的模型来演示一下整个流程：\n 首先创建一个叫“steamer”的HDA。然后将其划分为4部分：\n body 是蒸笼的主体，主要就是一个Tube在两边挤出然后利用polybridge掏空中间。    grid 是蒸笼每一层的网格底。\n就是简单的矩形变换然后和上面body的BaseTube做布尔运算切出需要的部分，就不上图了。\n  cap 是蒸笼的顶部原型盖子。\n  盖子部分我的做法是把一个平面投射到球体上，然后通过调整球体Y轴的半径来控制盖子的弧形感觉。\n关于UV的小技巧  虽然我们的模型面数很少，不过如果我们频繁HDA参数调整模型的拓扑结构，autouv所消耗的时间还是很多的，直观的感受就是电脑会卡一下。所以一般会在HDA的参数中添加一个启用UV的参数然后在switch节点中通过取值0或1来开关UV的自动展开。这样我们在频繁调整的时候就不会卡了。\n 程序化建模对于新手来说最需要注意的一点就是对于UV空间的重复利用。例如像我们的蒸笼模型中，我们的蒸笼主体其实就是一个蒸笼格子一个个往上摞。所以他们完全可以公用同一块UV空间。当然这并不是完全没有问题的，如果你需要在某个格子上添加特殊的细节的话这种公用方案就无法满足。还有一点就是在UE4里面光照贴图要求UV之间是不能重叠的。不过这个其实引擎已经帮我们想到了，在我们把模型导入引擎的时候，引擎默认会帮我们生成一套专门的用作光照相关的UV(当然我们自己生成也可以)。就像我之前所说的，目前来讲“在某个格子上添加特殊的细节”这种操作并不能在美术上让我更有竞争力，所以我选择放弃这一点自由度换取数字资产在管线和效率上的优势。\n导出fbx以及烘焙各种贴图  houdini对我们常用的fbx和各种贴图的支持也是很好的。其中fbx导出没什么可说的，大家都一样。关于贴图的烘焙我们可以通过Gamedev（SideFxLabs）的插件里的maps backer来完成。\n我们可以看到在maps backer中我们常用的几种例如法线贴图，Curature贴图，AO贴图等等都支持。\n我们在用SP的烘焙的时候有一个选项就是OnlyByMeshName的选项。而在houdini中我们可以通过在烘焙前利用align and distribute节点让不同名称的Mesh分开依次间隔排列，这样就达到了和OnlyByMeshName相同的效果。\n展望  之前还接触过PDG相关的东西，不过目前来讲自己还没有这种需求，如果以后有机会我还是愿意试试的。随着技术的发展各个细分领域都可能会出现或者已经存在更加专业的解决方案，很难再出现一个工具cover所有需求的情况。那么多关注自身工具链的构建将各种解决方案有机的结合起来在当下就成了一件很重要的事情。\n","description":"","id":28,"section":"posts","tags":["折腾日记","Houdini","3D美术","工具链"],"title":"将houdini procedural modeling加入自己的工作流","uri":"https://saberuster.github.io/posts/houdini-01/"},{"content":"前言  依稀记得上次折腾自己的博客还是2018年。后来感觉无非就是写博客展示出来，啥平台都可以啊。所以之后又在零零散散几个能写文章的平台（例如知乎）更新过一些文章。直到有一天我遇见了redblobgames，里面的文章有很多能交互的东西让人对文章的内容有更深的理解。本着“我也想这样”的本能开启了这次的折腾的不归路。\n关于为什么选择Hugo  主要因为自己本身对Golang比较熟悉所以选择了Hugo。万一拓展点什么功能说不定还能贡献点代码参与参与开源社区。\n博客的主要内容  2018年的时候其实对自己的认知还是一个纯码农。所以更多的关注的是自己感兴趣的一些技术趋势。后来发现能安心做个我心目中的超级码农和当科学家一样是一个门槛奇高无比的事情。因为我觉得当今的软件开发的技术迭代我觉得已经超越了个人能承受的极限，所以想在保证本职专业度的前提下再拓展自己新的认知领域是一件很难的事情，除非能做到站在更高的认知上俯瞰技术的发展。2年过去了，我选择对自己的定位做出一定调整哈哈，超级码农对我来说还是有点不太现实。\n扯了点别的，回到主题博客内容按我目前的构想主要还是先以编程技术为主，之后再包含一些自己折腾各种游戏设计，3D美术相关东西的心得吧，也借此让自己更加多元化一点。\n说好的交互内容呢  博客先支个摊出来熟悉熟悉代码，目前计划先拿个主题先顶着，以后先换个自己的主题然后开始折腾交互内容。\n最后 希望这次能够坚持下来吧!!! ","description":"","id":29,"section":"posts","tags":["折腾日记"],"title":"使用hugo重建我的博客","uri":"https://saberuster.github.io/posts/my-first-post/"},{"content":"saberuster 的名字来历  16,17年刚刚步入社会，那时正在迷 Fate，看到 Rust 后立志要做个 ruster 所以直接拿 saber 和 ruster 连起来就有了 saberuster，一直沿用至今。\n","description":"一个喜欢编程和折腾的追风少年","id":30,"section":"","tags":null,"title":"关于我","uri":"https://saberuster.github.io/about/"}]